#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-

require 'optparse'
require 'find'
require 'set'

VIDEO_EXTENSIONS = Set.new %w[
  .3gp
  .avi
  .divx
  .flv
  .m4a
  .m4v
  .mkv
  .mov
  .mp4
  .mpeg
  .mpg
  .part
  .ts
  .vob
  .webm
  .wmv
]

paths = []
print0 = false
recurse = true
open = false
pattern = nil
reverse = false
sort = nil

args = OptionParser.new nil do |opt|
  opt.banner = <<-EOF.gsub /^ */, ''
    Usage: #{File.basename __FILE__} [options] [dir, â€¦]

    Options:
  EOF

  opt.on '-0', '--print0' do
    print0 = true
  end

  opt.on '-1', '--no-recurse' do
    recurse = false
  end

  opt.on '-o', '--open' do
    open = true
  end

  opt.on '-p', '--pattern PATTERN', Regexp do |p|
    if pattern = p
      pattern = Regexp.new p.source, p.options | Regexp::IGNORECASE unless p.source =~ /\p{Lu}/
    end
  end

  opt.on '-r', '--reverse' do
    reverse = true
  end

  opt.on '-t', '--sort-mtime' do
    sort = :mtime
  end
end.parse ARGV

args = ['.'] if args.empty?

def append_video ps, path, pattern
  if File.file? path and VIDEO_EXTENSIONS.include? File.extname(path).downcase
    return if pattern and path !~ pattern
    ps << path
  end
end

if recurse
  Find.find *args do |path|
    append_video paths, path, pattern
  end
else
  Dir['*'].each do |path|
    append_video paths, path, pattern
  end
end

abort if paths.empty?

case sort
when :mtime
  paths.sort_by! { |f| -File.mtime(f).to_i }
end

paths.reverse! if reverse

if open
  exec 'vlc', *paths
else
  print print0 ? paths.join("\0") : paths.join("\n") << "\n"
end

