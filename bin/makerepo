#!/usr/bin/env python
#
# Copyright (c) 2015-2025 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

import collections
import os
import re
import socket
import subprocess
import sys
from argparse import ArgumentParser, RawTextHelpFormatter
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
from typing import Collection, Optional, Sequence

CACHE_DIR = Path("/var/cache/pacman/pkg")
LIB_DIR = Path("/var/lib/pacman/local")


def parser() -> ArgumentParser:
    parser = ArgumentParser()
    parser.formatter_class = lambda prog: RawTextHelpFormatter(prog, max_help_position=30)
    parser.add_argument("-d", "--delete", action="store_true", help="delete before creating a new pkg db")
    parser.add_argument("-n", "--name", dest="dbname", help="basename of pkg db (defaults to hostname)")
    parser.add_argument("-C", "--cache-dir", type=Path, help=f"default: {CACHE_DIR}", default=CACHE_DIR)
    parser.add_argument("-L", "--lib-dir", type=Path, help=f"default: {LIB_DIR}", default=LIB_DIR)
    return parser


def get_dbpath(cache_dir: Path, dbname: Optional[str]) -> Path:
    return cache_dir / (dbname or str(socket.gethostname()) + ".db.tar.gz")


def get_cached_packages(cache_dir: Path, *, newer_than: float) -> dict[str, list[Path]]:
    paths = collections.defaultdict(list)
    for p in cache_dir.glob("*.pkg.tar.*"):
        if (m := re.match(r"^(.*)-\w+.pkg.tar.[a-z]+$", p.name)) and p.stat().st_ctime > newer_than:
            paths[m.group(1)].append(p)
    return paths


def get_packages(cache_dir: Path, lib_dir: Path, *, newer_than: float) -> list[Path]:
    cached_packages = get_cached_packages(cache_dir, newer_than=newer_than)
    return [p for l in lib_dir.glob("*") for p in cached_packages[l.name] if l.is_dir()]


def sign_packages(packages: Collection[Path]) -> None:
    if not packages:
        return
    # Unlock gpg-agent
    print(f"Signing {len(packages)} package(s)", file=sys.stderr)
    subprocess.run(["gpg", "--detach-sign"], check=True, input="", stdout=subprocess.DEVNULL)
    ThreadPoolExecutor().map(lambda p: subprocess.run(["gpg", "--detach-sign", str(p)], check=True), packages)


def main(args: Sequence[str]) -> int:
    opts = parser().parse_args(args)
    dbpath = get_dbpath(opts.cache_dir, opts.dbname)
    dbmtime = 0.0
    if dbpath.exists():
        if opts.delete:
            print(f"> Deleting {dbpath}", file=sys.stderr)
            os.remove(dbpath)
        else:
            dbmtime = dbpath.stat().st_mtime

    packages = get_packages(opts.cache_dir, opts.lib_dir, newer_than=dbmtime)
    if not packages:
        print("No new packages", file=sys.stderr)
        return 0

    sign_packages([p for p in packages if not Path(f"{p}.sig").exists()])
    subprocess.run(["repo-add", "--new", "--sign", str(dbpath), *packages])

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
