#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2013 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'optparse'
require 'ostruct'
require 'erb'
require 'shellwords'
require 'fileutils'
require 'resolv'
require 'timeout'
require 'socket'
require 'net/imap'
require 'haus/logger'
load File.expand_path('../imappostsynchook', __FILE__)

class Mbsynclaunch
  COLORS = {
    :success  => [:x83],
    :info     => [:x81],
    :progress => [:x218],
    :warning  => [:magenta],
    :error    => [:red],
    :prompt   => [:white]
  }

  attr_reader :options, :lock, :logger, :threads, :next_sync, :sync_hook

  def initialize opts = {}
    @options = OpenStruct.new opts
    options.config ||= File.expand_path '~/.mbsyncrc.erb'
    options.delay ||= 10 * 60
    options.channel ||= 'sungpae.com'
    options.inbox_channel ||= 'inbox.sungpae.com'
    options.pidfile ||= File.expand_path '~/.local/run/mbsynclaunch.pid'
    options.post_sync_hook_options ||= {}
    @lock = Mutex.new
    @logger = Haus::Logger.new $stderr
    @threads = {}
    @next_sync = Time.now
    @killed = false
  end

  def parser
    @parser ||= OptionParser.new nil, 40 do |opt|
      opt.banner = <<-BANNER.gsub /^ +/, ''
        mbsync daemon

        * Syncs on fixed schedule
        * Syncs INBOX on IMAP IDLE EXISTS
        * Syncs or quits on signals or input via stdin

        Usage: #{File.basename __FILE__} [options]

        Options:
      BANNER

      opt.on '-c', '--config PATH', 'mbsync config file. May be an ERB template. [DEFAULT: %s]' % options.config do |arg|
        options.config = arg
      end

      opt.on '-d', '--delay SECONDS', Integer, '[DEFAULT: %d]' % options.delay do |arg|
        options.delay = arg
      end

      opt.on '-C', '--channel CHANNEL', '[DEFAULT: %s]' % options.channel do |arg|
        options.channel = arg
      end

      opt.on '-I', '--inbox-channel CHANNEL', '[DEFAULT: %s]' % options.inbox_channel do |arg|
        options.inbox_channel = arg
      end

      opt.on '-P', '--pidfile PATH', '[DEFAULT: %s]' % options.pidfile do |arg|
        options.pidfile = arg
      end

      opt.on '-o', '--post-sync-hook-options KEY:VALUE,â€¦', Array, 'Options hash to pass to IMAPPostSyncHook. [DEFAULT: none]' do |arg|
        options.post_sync_hook_options = Hash[arg.map { |a| a.split ':', 2 }]
      end
    end
  end

  def config
    @config ||= if options.config =~ /erb\z/
      ERB.new(File.read options.config).result
    else
      File.read options.config
    end
  end

  def delay
    options.delay
  end

  def channel
    options.channel
  end

  def inbox_channel
    options.inbox_channel
  end

  def pidfile
    options.pidfile
  end

  def post_sync_hook
    @post_sync_hook ||= IMAPPostSyncHook.new options.post_sync_hook_options
  end

  def killed?
    @killed
  end

  # The config file doesn't rely on newlines to delimit sections, but it feels
  # silly to implement an mbsyncrc parser here
  def mbsyncrc
    @mbsyncrc ||= Hash[config.split(/\n\n/).map do |section|
      lines = section.lines.map(&:strip).reject { |l| l =~ /\A\s*#\z/ }
      [lines.first.downcase, Hash[lines.drop(1).map { |l|
        k, v = l.split /\s+/, 2
        [k.downcase, v]
      }]]
    end.reject { |l| l.first.empty? }]
  end

  def imapstore
    chan = mbsyncrc['channel ' << inbox_channel.downcase]
    master = chan['master']
    imap = master[/:([^:]*):/, 1]
    mbsyncrc['imapstore ' << imap.downcase]
  end

  def imap_address
    @imap_address ||= begin
      dns = Resolv::DNS.new
      dns.timeouts = 5
      dns.getaddress(imapstore['host']).to_s
    end
  end

  def imap_port
    @imap_port ||= (imapstore['port'] || 993).to_i
  end

  def alive?
    File.exists? pidfile and Process.kill 0, File.read(pidfile).to_i
  rescue Errno::ESRCH
    false
  end

  # Implementation of Ping.pingecho from Ruby 1.8.7.
  # Pass an IP address string to avoid DNS resolution hangups when offline.
  #
  # cf. http://www.mikeperham.com/2009/03/15/socket-timeouts-in-ruby/
  #     for an alternate implementation.
  def connect_with_timeout ipaddr, port, timeout
    Timeout.timeout timeout do
      TCPSocket.new(ipaddr, port).close
    end
    true
  rescue Errno::ECONNREFUSED
    true
  rescue Timeout::Error, StandardError
    false
  end

  def if_reachable addr, port
    if connect_with_timeout addr, port, 1
      yield
    else
      log '%s is unreachable!' % [addr, port].join(':'), :warning
    end
  end

  def write_pidfile
    FileUtils.mkdir_p File.dirname(pidfile)
    File.open(pidfile, 'w') { |f| f.puts $$ }
  end

  def remove_pidfile
    FileUtils.rm_f pidfile
  end

  def log msg, style = nil
    logger.log ['[%s] %s' % [Time.now.strftime('%H:%M:%S'), msg], *(COLORS[style] || [])]
  end

  def human_time from, to
    seconds = (to - from).to_i
    seconds = 0 if seconds < 0

    h = seconds / 3600
    m = (seconds % 3600) / 60
    s = seconds % 60

    ary = []
    ary << "#{h} hour#{'s' if h > 1}"   if h > 0
    ary << "#{m} minute#{'s' if m > 1}" if m > 0
    ary << "#{s} second#{'s' if s > 1}" if s > 0

    case ary.size
    when 0 then 'Any time now'
    when 1 then ary.first
    when 2 then '%s and %s' % ary
    when 3 then '%s, %s, and %s' % ary
    end
  end

  def dequote quoted_string
    s = quoted_string[/\A"(.*)"\z/, 1] || quoted_string
    s.gsub /\\(.)/, '\1'
  end

  def sync chan, *hook_args
    log "START mbsync #{chan}", :progress
    start = Time.now

    IO.popen %Q[/bin/bash -c "exec mbsync -q -c <(cat) #{chan.shellescape}"], 'w' do |w|
      w.puts config
      w.close
    end

    status = $?.exitstatus

    post_sync_hook.run *hook_args

    time = human_time start, Time.now
    if status and status.zero?
      log "FINISHED mbsync #{chan} in #{time}", :success
    else
      log "FAILURE mbsync #{chan} aborted in #{time} with status #{status}", :error
    end
  end

  def kill_threads
    @killed = true

    log 'Killing threads', :warning
    threads[:inbox].kill
    threads[:schedule].kill

    log 'Reaping children', :warning
    Process.waitall

    log 'Joining threads', :warning
    threads[:inbox].join
    threads[:schedule].join
  end

  def sleep_till_next_sync
    remaining = (next_sync - Time.now).to_i
    (remaining / 60).times do
      return if Time.now > next_sync
      sleep 60
    end
    sleep [(next_sync - Time.now).to_i, 0].max
  end

  def run_schedule_thread
    @next_sync = Time.now
    threads[:schedule].run
  end

  # Also (re)starts inbox_thread. This is pretty terrible, but inbox_thread
  # was dying on exceptions thrown during blocking operations. This also
  # allows the scheduled thread to run before the idle thread without
  # synchronization.
  def schedule_thread
    Thread.new do
      begin
        log 'Starting scheduled sync', :progress

        loop do
          @next_sync = Time.now + delay
          if_reachable imap_address, imap_port do
            t = Thread.new { lock.synchronize { sync channel } }
            if threads[:inbox].nil? or not threads[:inbox].status
              threads[:inbox] = inbox_thread
            end
            t.join
          end
          sleep_till_next_sync
        end
      rescue StandardError => e
        log 'Scheduled sync thread exception: [%s] %s' % [e.class, e.to_s], :error
        log 'Retrying in %s' % human_time(Time.now, next_sync), :progress
        sleep_till_next_sync
        retry
      end
    end
  end

  def inbox_thread
    Thread.new do
      begin
        watch_inbox
      rescue StandardError => e
        log 'INBOX watcher exception: [%s] %s' % [e.class, e.to_s], :error
        log 'Polling for server availability', :progress
        available = false
        10.times do
          sleep 5
          if connect_with_timeout imap_address, imap_port, 1
            available = true
            break
          end
        end
        retry if available
      end
    end
  end

  def watch_inbox
    log 'Connecting INBOX watcher', :progress

    imap = Net::IMAP.new imapstore['host'],
                         :port => imap_port,
                         :ssl => { :ca_file => File.expand_path(imapstore['certificatefile']) }
    imap.login imapstore['user'], dequote(imapstore['pass'])
    imap.select 'INBOX'

    log 'Connected INBOX watcher', :success

    loop do
      begin
        # IDLE calls time out after 30 minutes.
        Timeout.timeout 20 * 60 do
          imap.idle do |resp|
            imap.idle_done if resp.kind_of? Net::IMAP::UntaggedResponse and resp.name == 'EXISTS'
          end
        end
      rescue Timeout::Error
        next
      end

      if imap.status('INBOX', ['UNSEEN'])['UNSEEN'] > 0
        log 'New message in INBOX', :info
        lock.synchronize { sync inbox_channel, 'notify' } unless lock.locked?
      end
    end
  ensure
    unless imap.disconnected?
      imap.disconnect
      log 'Disconnected INBOX watcher', :warning
    end
  end

  def register_signal_handlers!
    trap :HUP do
      if lock.locked?
        log 'Received SIGHUP, but sync already in progress!', :warning
      else
        log 'Received SIGHUP, starting sync', :progress
        run_schedule_thread
      end
    end

    term_signals = [:INT, :TERM, :QUIT]
    term_signals.each do |sig|
      trap sig do
        term_signals.each { |sig| trap sig, 'DEFAULT' }
        log "Received SIG#{sig}", :warning
        kill_threads unless killed?
      end
    end
  end

  def command_thread input_stream = $stdin
    Thread.new do
      loop do
        select [input_stream]

        case input = input_stream.gets("\n").chomp
        when /\Ar/i
          if lock.locked?
            log 'Sync already in progress!', :warning
          else
            run_schedule_thread
          end
        when /\Ad/i
          begin
            require 'pry'
            binding.send $stdin.tty? ? :pry : :remote_pry
          rescue LoadError => e
            log '[%s] %s' % [e.class, e.to_s], :error
          end
        when /\Aq/i
          kill_threads
          break
        else
          t = input =~ /\A[t]/i

          if t or input.empty?
            if lock.locked?
              log 'Sync in progress!', :info
            else
              log human_time(Time.now, next_sync), :info
            end
          end

          unless t
            log 'Commands: [R]esync, [T]ime until next sync, [D]ebug, [Q]uit', :prompt
          end
        end
      end
    end
  end

  def run arguments = []
    args = parser.parse arguments
    abort 'mbsynclaunch is already running!' if alive?
    write_pidfile

    threads[:schedule] = schedule_thread
    command_thread

    register_signal_handlers!

    threads[:schedule].join
  ensure
    remove_pidfile
  end
end

$0 = File.basename(__FILE__) and Mbsynclaunch.new.run ARGV if $0 == __FILE__
