#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-

require 'erb'
require 'shellwords'
require 'fileutils'
require 'net/imap'
require 'haus/logger'
load File.expand_path('../imappostsynchook', __FILE__)

@wait = 5 * 60
@next = Time.now
@lock = Mutex.new
@sync = IMAPPostSyncHook.new
@conf = ERB.new(File.read File.expand_path('~/.mbsyncrc.erb')).result
@logger = Haus::Logger.new $stderr
@threads = {}
@program = File.basename __FILE__
@pidfile = File.expand_path "~/.local/share/mbsync/#{@program}.pid"

$0 = @program

def running? pid
  Process.kill 0, pid
rescue Errno::ESRCH
  false
end

def log msg, *styles
  @logger.log ['[%s] %s' % [Time.now.strftime('%H:%M:%S'), msg], *styles]
end

def mbsync channel
  log "START mbsync #{channel}", :green, :bold
  start = Time.now

  IO.popen "/bin/bash -c \"exec mbsync -q -c <(cat) #{channel.shellescape}\"", 'w' do |w|
    w.puts @conf
    w.close
  end

  @sync.run

  log "END mbsync #{channel} (#{human_time start, Time.now})", :green, :bold
  display_prompt
end

def kill_threads threads
  threads.each_value &:kill
  Process.waitall
  threads.each_value &:join
end

def human_time from, to
  seconds = (to - from).to_i
  seconds = 0 if seconds < 0

  h = seconds / 3600
  m = (seconds % 3600) / 60
  s = seconds % 60

  ary = []
  ary << "#{h} hour#{'s' if h > 1}"   if h > 0
  ary << "#{m} minute#{'s' if m > 1}" if m > 0
  ary << "#{s} second#{'s' if s > 1}" if s > 0

  case ary.size
  when 0 then 'Any time now…'
  when 1 then ary.first
  when 2 then '%s and %s' % ary
  when 3 then '%s, %s, and %s' % ary
  end
end

def display_prompt
  @logger.io.print @logger.fmt(["\rCommands: [R]esync, [T]ime until next sync, [Q]uit # ", :white])
end

# Write pidfile
if File.exists? @pidfile and running? File.read(@pidfile).to_i
  abort "#{@program} is already running!"
else
  FileUtils.mkdir_p File.dirname(@pidfile)
  File.open(@pidfile, 'w') { |f| f.puts $$ }
end

# Poll all mailboxes
@threads[:poll] = Thread.new do
  loop do
    @lock.synchronize { mbsync 'sungpae.com' }
    @next = Time.now + @wait
    sleep @wait
  end
end

# Fetch INBOX on IMAP IDLE
@threads[:idle] = Thread.new do
  begin
    imap = Net::IMAP.new 'imap.gmail.com',
                         :port => 993,
                         :ssl => { :ca_file => File.expand_path('~/.certificates/gmail.crt') }
    imap.login 'self@sungpae.com', %x(pass google.com/self@sungpae.com).chomp
    imap.select 'INBOX'

    loop do
      imap.idle do |resp|
        imap.idle_done if resp.kind_of? Net::IMAP::UntaggedResponse and resp.name == 'EXISTS'
      end

      if imap.status('INBOX', ['UNSEEN'])['UNSEEN'] > 0
        log 'New message in INBOX', :x150
        @lock.synchronize { mbsync 'inbox.sungpae.com' } unless @lock.locked?
      end
    end
  rescue
    log '[%s] %s' % [$!.class, $!.to_s], :red
  ensure
    log 'Disconnecting IMAP', :yellow
    imap.logout
  end
end

# Register signal handlers
trap :USR1 do
  log "\nReceived SIGUSR1; starting sync…", :x158
  if @lock.locked?
    log 'Sync already in progress!', :yellow
  else
    @threads[:poll].run
  end
end

term_signals = [:INT, :TERM, :QUIT, :USR2]
term_signals.each do |sig|
  trap sig do
    term_signals.each { |sig| trap sig, 'DEFAULT' }
    log "Received SIG#{sig}; killing threads…", :magenta, :bold
    kill_threads @threads
    exit
  end
end

# Process user input
begin
  loop do
    select [$stdin]

    case $stdin.gets("\n")
    when /\Ar/i
      unless @lock.locked?
        warn
        @threads[:poll].run
      end
    when /\A[t?]/i
      log human_time(Time.now, @next), :x217
    when /\Aq/i
      break
    end

    display_prompt unless @lock.locked?
  end
ensure
  kill_threads @threads
end

log 'Graceful shutdown.', :green
