#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2012 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'optparse'
require 'ostruct'
require 'openssl'
require 'shellwords'
require 'net/http'
require 'digest/sha1'
require 'digest/md5'

class Dumpcert
  module Certificate
    extend self

    def parse string
      certs = string.scan /-+BEGIN CERTIFICATE-+\n.*?\n-+END CERTIFICATE-+/m

      if certs.any?
        certs.map { |pem| OpenSSL::X509::Certificate.new pem }
      else
        # Maybe DER format?
        [OpenSSL::X509::Certificate.new(string)]
      end
    rescue OpenSSL::X509::CertificateError
      []
    end

    def parse_server_arg server
      h, p = server.split ':', 1
      p = p.to_i if p
      [h, p]
    end

    def self_signed? cert
      cert.subject.eql? cert.issuer
    end

    def equal? a, b
      a.subject.eql? b.subject and a.issuer.eql? b.issuer
    end

    def ssl_get host, port = nil
      server = "#{host}:#{port || 443}".shellescape
      certs = parse %x(openssl s_client -connect #{server} < /dev/null 2>/dev/null)
      raise 'Multiple certificates returned from %s' % host if certs.count > 1
      certs.first
    end

    def http_get url
      certs = parse Net::HTTP.get(URI.parse url)
      raise 'Multiple certificates returned from %s' % url if certs.count > 1
      certs.first
    end

    def get url
      case url
      when /\.html$/ then http_get url
      else ssl_get *parse_server_arg(url)
      end
    end

    def get_chain url
      chain = []
      cert = get url

      loop do
        chain.push cert
        break unless cert.extensions.find { |e| e.oid == 'authorityInfoAccess' and e.value =~ /URI:(http.*?\.crt)/ }
        break unless cert = http_get($1)
      end

      chain
    end
  end

  attr_reader :options

  def initialize opts = {}
    @options = OpenStruct.new opts
    options.cabundle ||= File.expand_path '~/.certificates/cabundle.pem'
  end

  def parser
    @parser ||= OptionParser.new nil, 16 do |opt|
      opt.banner = <<-BANNER.gsub /^ {8}/, ''
        Usage: #{File.basename __FILE__} [options] command [args]

        Arguments can be host:port, a PEM or DER certificate file, or '-' for STDIN.

        Commands:

            dump [arg ...]   Dump certificates (or cabundle) to stdout
            add arg ...      Add certificate roots to cabundle
            rm arg ...       Remove certificate roots from cabundle
            exec arg ...     Run a command with CURL_CA_BUNDLE and GIT_SSL_CAINFO set to cabundle
            console          Open a Pry debugging session

        Options:
      BANNER

      opt.on '-f', '--cabundle PATH', 'File containing CA Roots [DEFAULT: %s]' % options.cabundle do |arg|
        options.cabundle = File.expand_path arg
      end
    end
  end

  def format certs
    certs.map do |c|
      [ 'Subject: %s' % c.subject,
        'Issuer:  %s' % c.issuer,
        'SHA1:    %s' % Digest::SHA1.hexdigest(c.to_der),
        'MD5:     %s' % Digest::MD5.hexdigest(c.to_der),
        c.to_s
      ].join "\n"
    end.join
  end

  def cabundle
    Certificate.parse File.read(options.cabundle)
  end

  def write_cabundle certs
    File.open options.cabundle, 'w' do |f|
      f.puts format(certs.sort_by { |c| c.subject.to_s })
    end
  end

  def mapcerts args = []
    args.map do |arg|
      if arg == '-'
        Certificate.parse $stdin.read
      elsif File.readable? arg
        Certificate.parse File.read(arg)
      else
        Certificate.get_chain arg
      end
    end.flatten.compact
  end

  def maproots args = []
    mapcerts(args).select { |c| Certificate.self_signed? c }
  end

  def dump *args
    puts format(args.empty? ? cabundle : mapcerts(args))
  end

  def add *args
    write_cabundle maproots(args).reduce(cabundle) { |certs, root|
      certs << root unless certs.find { |c| Certificate.equal? c, root }
      certs
    }
  end

  def rm *args
    write_cabundle maproots(args).reduce(cabundle) { |certs, root|
      certs.reject { |c| Certificate.equal? c, root }
    }
  end

  def exec *args
    env = { 'CURL_CA_BUNDLE' => options.cabundle, 'GIT_SSL_CAINFO' => options.cabundle }
    Kernel.exec env, *args
  end

  def console *args
    require 'pry'
    cs = mapcerts args
    binding.pry
  end

  def run arguments = []
    args = parser.parse arguments
    rest = args.drop 1

    case args.first
    when nil then dump
    when 'dump' then dump *rest
    when 'add' then add *rest
    when 'rm' then rm *rest
    when 'exec' then exec *rest
    when 'console' then console *rest
    else abort parser.help
    end
  end
end

$0 = File.basename(__FILE__) and Dumpcert.new.run ARGV if $0 == __FILE__
