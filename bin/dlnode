#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2014-2017 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'optparse'
require 'fileutils'
require 'uri'
require 'shellwords'
require 'nokogiri'
require 'haus/utils'

class Dlnode; end

class Dlnode::Pattern
  attr_accessor :selector, :attribute, :regexp, :gsub

  def initialize pattern_str
    @selector, @attribute, @regexp, @gsub = parse pattern_str
  end

  def blank? x
    x.nil? or x.empty?
  end

  def default_attribute elem
    case elem
    when 'a' then 'href'
    when 'img' then 'src'
    end
  end

  def parse pattern_str
    a, b, c, d = pattern_str.split /(?<!\\):/, 4

    [blank?(a) ? 'a' : a,
     blank?(b) ? nil : b,
     blank?(c) ? nil : Haus::Utils.regexp_parse(c),
     blank?(d) ? nil : parse_gsub(d)]
  end

  def parse_gsub gsub_str
    pat, rep = gsub_str.split /(?<!\\),/, 2
    [Haus::Utils.regexp_parse(pat), rep || '']
  end
end

class Dlnode::Resource
  attr_accessor :url, :referer, :form_data, :base_uri

  def initialize url = nil, opts = {}
    @url = url
    @form_data = opts[:form_data]
    @referer = opts[:referer]
    @base_uri = opts[:base_uri]
  end

  def urijoin base, path
    URI.join(base, path).to_s
  rescue URI::InvalidURIError
    # Maybe the path isn't properly escaped
    begin
      URI.join(base, URI.escape(path)).to_s
    rescue URI::InvalidURIError
    end
  end

  def extract_resources pattern, opts
    html_str = fetch opts

    return [] if html_str.nil?

    html_str.gsub! *pattern.gsub if pattern.gsub

    Nokogiri::HTML.parse(html_str).css(pattern.selector).reduce [] do |v, el|
      if not pattern.attribute and el.name == 'form'
        form_data = el.css('input').map { |i| [i['name'], i['value']] }
        path = el.attr 'action'
      else
        attr = pattern.attribute || pattern.default_attribute(el.name)
        path = attr ? el.attr(attr) : el.text
      end

      if path and u = urijoin(base_uri || url, path)
        r = self.class.new u, :form_data => form_data, :base_uri => base_uri, :referer => (url if opts[:send_referer] and url !~ %r{\Afile://})
        r = nil if pattern.regexp and u !~ pattern.regexp
      end

      r ? v << r : v
    end
  end

  def command opts = {}
    ref = ['--referer', referer] if referer
    cmd = ['curl', '--silent', *Dlnode.common_curl_args(opts), *ref]

    form_data.each do |kv|
      cmd << '--form-string' << kv.map { |e| URI.encode_www_form_component e }.join('=')
    end if form_data

    cmd.concat opts[:curl_opts] if opts[:curl_opts]

    cmd << url
  end

  def fetch opts = {}
    cmd = command opts
    warn cmd.shelljoin if opts[:verbose]
    buf = IO.popen(cmd) { |io| io.read }

    if $?.exitstatus.zero?
      $stderr.print "\e[32m.\e[0m"
      buf
    else
      $stderr.print "\e[31m.\e[0m\nFAILED to %s %s\n" % [form_data ? 'POST' : 'GET', url]
      nil
    end
  end

  def fetch_leaves patterns = [], opts = {}
    p, *rest = patterns
    resources = extract_resources p, opts

    if rest.any?
      resources.flat_map { |r| r.fetch_leaves rest, opts }
    else
      if opts[:verbose]
        if resources.empty?
          warn "\e[31mEmpty branch: #{url}\e[0m"
        else
          warn "\e[32mBranch #{url} leaf count: #{resources.size}\e[0m"
        end
      end
      resources
    end
  end
end

class Dlnode
  DEFAULTS = {
    :base_uri => nil,
    :cookie_jar => nil,
    :dir => '.',
    :dir_from_url => false,
    :format => nil,
    :index => 1,
    :start => 1,
    :max_time => nil,
    :connect_timeout => nil,
    :no_download => false,
    :send_referer => false,
    :user_agent => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36',
    :retry => nil,
    :verbose => false
  }

  def initialize opts = {}
    DEFAULTS.each_key { |k| instance_variable_set "@#{k}", opts.has_key?(k) ? opts[k] : DEFAULTS[k] }
  end

  def parser
    @parser ||= OptionParser.new nil, 32 do |opt|
      opt.banner = <<-BANNER.gsub /^ +/, ''
        Download nested HTML resources. Uses cURL.

        Usage: #{File.basename __FILE__} [options] url-or-path [selector=a]:[attribute=href]:[regexp]:[gsub] …

        dlnode http://files.example.com/ a:href:subhost.com 'a[id=download]:href:\\.tar\\.gz$'
        dlnode http://files.example.com/ ::subhost.com form[rel=lolcat]:: img[class=lolcat]:src:

        Options:
      BANNER

      opt.on '-b', '--base-uri URL', 'Set an alternate base uri for relative links in file:// urls' do |arg|
        @base_uri = arg
      end

      opt.on '-c', '--cookie-jar PATH', 'Same as `curl --cookie-jar`' do |arg|
        @cookie_jar = File.expand_path arg
      end

      opt.on '-d', '--dir PATH', 'Download directory; current working directory by default' do |arg|
        @dir = File.expand_path arg
      end

      opt.on '-D', '--dir-from-url', 'Set --dir to munged domain + path' do |arg|
        @dir_from_url = true
      end

      opt.on '-f', '--format [DIR/]BASE-%02d', 'Rename resources with given format spec' do |arg|
        if arg =~ %r{.+/.+}
          @dir, _, @format = arg.rpartition '/'
        else
          @format = arg
        end
      end

      opt.on '-i', '--index N[:START]', 'Begin index at N, and skip until START' % @index do |arg|
        @index, @start = arg.split(':', 2).map &:to_i
        @start = @index if @start.nil? or @start < @index
      end

      opt.on '-m', '--max-time SECONDS', Integer, 'Same as `curl --max-time`' do |arg|
        @max_time = arg
      end

      opt.on '-n', '--no-download', 'Do not download resources, but print the commands that would be executed' do |arg|
        @no_download = true
      end

      opt.on '-r', '--retry N', Integer, "DEFAULT: #{DEFAULTS[:retry]}" do |arg|
        @retry = arg
      end

      opt.on '-t', '--connect-timeout SECONDS', Integer, 'Same as `curl --connect-timeout`' do |arg|
        @connect_timeout = arg
      end

      opt.on '-v', '--verbose' do
        @verbose = true
      end

      opt.on '-A', '--user-agent STRING', "DEFAULT: #{DEFAULTS[:user_agent]}" do |arg|
        @user_agent = arg
      end

      opt.on '-O', '--curl-opts OPTS', 'Extra options to pass directly to cURL' do |arg|
        @curl_opts = arg.shellsplit
      end

      opt.on '-R', '--send-referer', 'Send HTTP Referer (sic) headers when fetching resources' do
        @send_referer = true
      end
    end
  end

  def self.common_curl_args opts = {}
    args = ['--fail', '--location', '--user-agent', opts[:user_agent] || DEFAULTS[:user_agent]]
    args.concat ['--cookie-jar', opts[:cookie_jar]] if opts[:cookie_jar]
    args.concat ['--retry', opts[:retry].to_s] if opts[:retry]
    args.concat ['--max-time', opts[:max_time].to_s] if opts[:max_time]
    args.concat ['--connect-timeout', opts[:connect_timeout].to_s] if opts[:connect_timeout]
    args
  end

  def url_basename url
    File.basename URI.parse(url).path
  end

  def format_filename fmt, idx, file
    if fmt.index '%s'
      fmt % [idx, File.extname(file)]
    else
      (fmt % idx) << File.extname(file)
    end
  end

  # Returns array of arguments for exec: […, path, url]
  def command resource, idx, opts = options
    f = url_basename resource.url
    path = File.join opts[:dir], (opts[:format] ? format_filename(opts[:format], idx, f) : f)
    ref = ['--referer', resource.referer] if resource.referer

    ['curl', '--progress-bar',
             *Dlnode.common_curl_args(opts),
             *ref,
             *opts[:curl_opts],
             '--output', path,
             resource.url]
  end

  def map_commands resources, opts = options
    Δ = opts[:start] - opts[:index]

    resources.drop(Δ).map.with_index do |r, i|
      command r, i + opts[:index] + Δ, opts
    end
  end

  def options
    {
      :index => @index,
      :start => @start,
      :cookie_jar => @cookie_jar,
      :dir => @dir,
      :format => @format,
      :send_referer => @send_referer,
      :user_agent => @user_agent,
      :curl_opts => @curl_opts,
      :retry => @retry,
      :max_time => @max_time,
      :connect_timeout => @connect_timeout,
      :verbose => @verbose
    }
  end

  def download! url, *pattern_args
    opts = options
    patterns = pattern_args.map { |p| Pattern.new p }
    resources = Resource.new(url, :base_uri => @base_uri).fetch_leaves patterns, opts
    commands = map_commands resources, opts

    if commands.empty?
      warn "\nNo resources found!"
      :no_resources
    elsif @no_download
      warn "\n%d resource(s)" % resources.size
      puts commands.map(&:shelljoin)
      :ok
    else
      $stderr.puts
      FileUtils.mkdir_p @dir

      n = resources.size
      failed = []

      commands.each_with_index do |cmd, i|
        path, url = cmd[-2..-1]

        warn "[#{i+1}/#{n}] #{url} → #{path}"

        if File.exists? path
          warn 'File exists!'
        else
          warn cmd.shelljoin if @verbose
          system *cmd
          failed << cmd if not $?.exitstatus.zero?
        end
      end

      if failed.any?
        $stderr.puts "\e[31mFAILED:\e[0m "
        failed.each { |cmd| puts cmd.shelljoin }
        :fail
      else
        :ok
      end
    end
  end

  def run arguments = []
    args = parser.parse arguments
    abort parser.help unless args.size > 1
    url, *rest = args
    url = "file://#{URI.escape File.expand_path(url)}" if url !~ %r{\w+://}

    if @dir_from_url and @dir == DEFAULTS[:dir]
      u = URI.parse url
      @dir = [u.host, u.path].map { |x| x.tr('/', '-').gsub(/[^\p{Print}]/, '_') }.join
    end

    case download! url, *rest
    when :no_resources then exit 2
    when :fail then exit 1
    end
  end
end

$0 = File.basename(__FILE__) and Dlnode.new.run ARGV if $0 == __FILE__
