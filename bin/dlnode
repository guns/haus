#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2014 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'optparse'
require 'fileutils'
require 'uri'
require 'shellwords'
require 'nokogiri'

class Dlnode
  DEFAULTS = {
    :dir => '.',
    :format => nil,
    :index => 1,
    :start => 1,
    :no_download => false,
    :send_referer => false,
    :user_agent => 'Mozilla/5.0',
    :curl_opts => []
  }

  def self.urijoin base, path
    URI.join(base, path).to_s
  rescue URI::InvalidURIError
  end

  def self.extract_resources resource, pattern, opts
    html_str = resource.fetch opts

    return [] if html_str.nil?

    Nokogiri::HTML.parse(html_str).css(pattern.selector).reduce [] do |v, el|
      if not pattern.attribute and el.name == 'form'
        form_data = el.css('input').map { |i| [i['name'], i['value']] }
        path = el.attr 'action'
      else
        path = pattern.attribute ? el.attr(pattern.attribute) : el.text
      end

      if path and url = urijoin(resource.url, path)
        r = Resource.new url, form_data, (resource.url if opts[:send_referer])
        r = nil if pattern.regexp and url !~ pattern.regexp
      end

      r ? v << r : v
    end
  end

  class Pattern
    attr_accessor :selector, :attribute, :regexp

    def initialize pattern_str
      @selector, @attribute, @regexp = parse pattern_str
    end

    def blank? x
      x.nil? or x.empty?
    end

    def parse pattern_str
      a, b, c = pattern_str.split /(?<!\\):/, 3

      sel  = blank?(a) ? 'a'                         : a
      attr = blank?(b) ? (sel == 'a' ? 'href' : nil) : b
      rgx  = blank?(c) ? nil                         : Regexp.new(c)

      [sel, attr, rgx]
    end
  end

  class Resource
    attr_accessor :url, :referer, :form_data

    def initialize url = nil, form_data = nil, referer = nil
      @url = url
      @form_data = form_data
      @referer = referer
    end

    def command opts = {}
      curl_opts  = opts[:curl_opts ] || ::Dlnode::DEFAULTS[:curl_opts ]
      user_agent = opts[:user_agent] || ::Dlnode::DEFAULTS[:user_agent]

      cmd = ['curl', '-sfLA', user_agent, *(referer ? ['-e', referer] : [])]

      form_data.each do |kv|
        cmd << '--form-string' << kv.map { |e| URI.encode_www_form_component e }.join('=')
      end if form_data

      cmd.concat curl_opts

      cmd << url
    end

    def fetch opts = {}
      buf = IO.popen(command opts) { |io| io.read }

      if $?.exitstatus.zero?
        $stderr.print "\e[32m.\e[0m"
        buf
      else
        $stderr.print "\e[31m.\e[0m\nFAILED to %s %s\n" % [form_data ? 'POST' : 'GET', url]
        nil
      end
    end

    def fetch_leaves patterns = [], opts = {}
      p, *rest = patterns
      resources = ::Dlnode.extract_resources self, p, opts

      if rest.any?
        resources.flat_map { |r| r.fetch_leaves rest, opts }
      else
        resources
      end
    end
  end

  def initialize opts = {}
    DEFAULTS.each_key { |k| instance_variable_set "@#{k}", opts[k] || DEFAULTS[k] }
  end

  def parser
    @parser ||= OptionParser.new nil, 28 do |opt|
      opt.banner = <<-BANNER.gsub /^ +/, ''
        Download nested HTML resources. Uses cURL.

        Usage: #{File.basename __FILE__} [options] url [selector=a]:[attribute=href]:[regexp] …

        dlnode http://files.example.com/ a:href:subhost.com 'a[id=download]:href:\\.tar\\.gz$'
        dlnode http://files.example.com/ ::subhost.com form[rel=lolcat]:: img[class=lolcat]:src:

        Options:
      BANNER

      opt.on '-d', '--dir PATH', 'Download directory; current working directory by default' do |arg|
        @dir = File.expand_path arg
      end

      opt.on '-f', '--format [DIR/]BASE-%02d', 'Rename resources with given format spec' do |arg|
        if arg =~ %r{.+/.+}
          @dir, _, @format = arg.rpartition '/'
        else
          @format = arg
        end
      end

      opt.on '-i', '--index N[:START]', 'Begin index at N, and skip until START' % @index do |arg|
        @index, @start = arg.split(':', 2).map &:to_i
        @start = @index if @start.nil? or @start < @index
      end

      opt.on '-n', '--no-download', 'Do not download resources, but print the commands that would be executed' do |arg|
        @no_download = true
      end

      opt.on '-r', '--send-referer', 'Send HTTP Referer (sic) headers when fetching resources' do
        @send_referer = true
      end

      opt.on '-A', '--user-agent STRING', "DEFAULT: #{DEFAULTS[:user_agent]}" do |arg|
        @user_agent = arg
      end

      opt.on '-O', '--curl-opts OPTS', 'Extra options to pass directly to cURL' do |arg|
        @curl_opts = arg.shellsplit
      end
    end
  end

  def url_basename url
    File.basename URI.parse(url).path
  end

  def format_filename fmt, idx, file
    if fmt.index '%s'
      fmt % [idx, File.extname(file)]
    else
      (fmt % idx) << File.extname(file)
    end
  end

  # Returns tuple of arguments for exec: […, path, url]
  def command resource, idx, dir, opts = {}
    f = url_basename resource.url
    path = File.join dir, (opts[:format] ? format_filename(opts[:format], idx, f) : f)

    ['curl', '-#fLA', opts[:user_agent] || DEFAULTS[:user_agent],
             *(resource.referer ? ['-e', resource.referer] : []),
             *opts[:curl_opts],
             '-o', path, resource.url]
  end

  def map_commands resources, opts = {}
    Δ = opts[:start] - opts[:index]

    resources.drop(Δ).map.with_index do |r, i|
      command r, i + opts[:index] + Δ, opts[:dir],
              :format => opts[:format],
              :user_agent => opts[:user_agent],
              :curl_opts => opts[:curl_opts]
    end
  end

  def download! url, *pattern_args
    opts = {
      :index => @index,
      :start => @start,
      :dir => @dir,
      :format => @format,
      :send_referer => @send_referer,
      :user_agent => @user_agent,
      :curl_opts => @curl_opts
    }
    patterns = pattern_args.map { |p| Pattern.new p }
    resources = Resource.new(url).fetch_leaves patterns, opts
    commands = map_commands resources, opts

    if commands.empty?
      warn "\nNo resources found!"
      false
    elsif @no_download
      warn "\n%d resource(s)" % resources.size
      puts commands.map(&:shelljoin)
      true
    else
      warn "\nDownloading %d resource(s)" % resources.size

      FileUtils.mkdir_p @dir

      failed = []

      commands.each do |cmd|
        path, url = cmd[-2..-1]

        warn "#{url} → #{path}"

        if File.exists? path
          warn 'File exists!'
        else
          system *cmd
          failed << cmd if not $?.exitstatus.zero?
        end
      end

      if failed.any?
        $stderr.print "\e[31mFAILED:\e[0m "
        failed.each { |cmd| puts cmd.shelljoin }
      end

      failed.empty?
    end
  end

  def run arguments = []
    args = parser.parse arguments
    abort parser.help unless args.size > 1
    download! *args or abort
  end
end

$0 = File.basename(__FILE__) and Dlnode.new.run ARGV if $0 == __FILE__
