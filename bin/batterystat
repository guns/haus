#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2011 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

$:.unshift File.expand_path('../../lib', __FILE__)

require 'optparse'
require 'time'
require 'haus/logger'

class Batterystat
  class DarwinStat
    include Haus::Loggable

    def data
      @data ||= ioreg '-n AppleSmartBattery'
    end

    # From AppleSmartBattery.cpp:
    #
    #   Date is published in a bitfield per the Smart Battery Data spec rev
    #   1.1 in section 5.1.26
    #     Bits 0...4 => day (value 1-31; 5 bits)
    #     Bits 5...8 => month (value 1-12; 4 bits)
    #     Bits 9...15 => years since 1980 (value 0-127; 7 bits)
    def battery_age
      bf    = data['ManufactureDate'].to_i
      day   = bf & ((2**5)-1)
      month = (bf & (((2**4)-1) << 5)) >> 5
      year  = ((bf & (((2**7)-1) << 9)) >> 9) + 1980
      date  = Time.strptime ('%0d %0d %d' % [day, month, year]), '%d %m %Y'

      # Return age in years (avg from Google calculator)
      '%s (%.2f years old)' % [date.strftime('%d %b %Y'), (Time.now - date) / (60*60*24*365.242199)]
    end

    def ioreg query
      Hash[%x(/usr/sbin/ioreg -w0 -d1 -S -x -r #{query}).lines.drop(1).grep(/=/).map { |l| parse l }]
    end

    def parse line
      left, right = line.split('=', 2).map &:strip
      [left.gsub(/\W/, ''), str2val(right)]
    end

    def str2val str
      case str
      when /\A0x\h+\z/    then str.to_i 16
      when /\AYes|No\z/   then str == 'Yes'
      when /\A"(.*)"\z/   then $1
      when /\A\((.*)\)\z/ then $1.split(',').map { |e| str2val e.strip } # Recurse!
      when /\A\{(.*)\}\z/ then Hash[$1.split(',').map { |e| parse e }]   # Mutually recurse!
      else str
      end
    end

    def terminal_width
      return ENV['COLUMNS'].to_i if ENV['COLUMNS'] =~ /\A\d+\z/
      cols = %x(tput cols) rescue nil
      return cols.to_i if cols
      80
    end

    # Returns [graph, val, base]
    def values val, base, len
      # Normalize for display
      k = val.to_f / base
      k = 0 if k < 0
      k = 1 if k > 1

      pct   = (k * 100).round
      bars  = (len * k).round
      graph = (['|'] * bars) + ([' '] * (len - bars))
      graph[-(pct.to_s.size+1)..-1] = (pct.to_s + '%').split('')

      [fmt([graph.take(bars).join, color(k), :bold], graph.drop(bars).join), val, base]
    end

    def color k
      if Haus::Logger.colors256?
        # Eleven gradations of red to green
        colors = (196.step(226, 6).to_a + 190.step(46, -36).to_a).map { |n| "x#{n}".to_sym }
        colors[(k * 10).round]
      else
        case k
        when 0.75..1.0 then :green
        when 0.5..0.75 then :cyan
        when 0.25..0.5 then :yellow
        when 0.1..0.25 then :magenta
        else                :red
        end
      end
    end

    # Mirrors coconutBattery output
    def to_s width = nil
      width ||= terminal_width

      lines = []
      lines.push 'Charge [%s] %d/%d mAh'
      lines.push 'Health [%s] %d/%d mAh'
      lines.push ''
      if data['IsCharging']
        lines << 'Time to full: %d minutes' % data['AvgTimeToFull']
      else
        lines << 'Remaining:    %d minutes' % data['TimeRemaining']
      end
      lines.push 'Manufactured: %s'     % battery_age
      lines.push 'Loadcycles:   %d'     % data['CycleCount']
      lines.push 'Temperature:  %.2fÂ°C' % (data['Temperature'].to_f / 100)

      # Calculate graph length
      dsn = data['DesignCapacity']
      len = width - (lines[0] % ['', dsn, dsn]).length
      raise 'Not enough space to display graph!' if len < 0

      # Graph current charge and battery health
      cur, max = data.values_at *%w[CurrentCapacity MaxCapacity]
      lines[0] = lines[0] % values(cur, max, len)
      lines[1] = lines[1] % values(max, dsn, len)

      lines.join "\n"
    end

    def to_json
      data.merge('CurrentDate' => Time.now.utc).to_json
    end
  end

  def initialize args = []
    @args = args.freeze
    @opts = {}
  end

  def options
    OptionParser.new do |opt|
      opt.summary_width = 16
      opt.banner = %Q(\
        Statistics about your machine's battery. Currently OS X only.

        Usage: #{File.basename __FILE__} [options]

        Options:
      ).gsub /^ +/, ''

      opt.on '-w', '--width N', Integer, 'Limit output to given width' do |arg|
        @opts[:width] = arg
      end

      opt.on '-j', '--json', 'Dump JSON serialization of battery data' do
        require 'json'
        @opts[:json] = true
      end
    end
  end

  def stat
    @stat ||= case RUBY_PLATFORM
    when /darwin/i then DarwinStat.new
    else raise ArgumentError, "Unsupported platform: #{RUBY_PLATFORM}"
    end
  end

  def run
    args = options.parse @args
    abort options.to_s if not args.empty?
    puts @opts[:json] ? stat.to_json : stat.to_s(@opts[:width])
  end
end

Batterystat.new(ARGV).run if $0 == __FILE__
