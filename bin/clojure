#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2012 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'ostruct'
require 'pathname'
require 'shellwords'
require 'cli/superparser'

class Clojure
  attr_reader :options

  def initialize opts = {}
    @options = OpenStruct.new opts
    options.classpath  ||= (ENV['CLASSPATH'] || '').split ':'
    options.ngport     ||= 2113
  end

  def parser
    @parser ||= CLI::SuperParser.new nil, 28 do |opt|
      opt.banner = %Q(\
        Clojure wrapper.

        Usage: #{File.basename __FILE__} [options] [java-options] [java-arguments]

        Options:
      ).gsub /^ +/, ''

      opt.on '-p', '--classpath a:b:c', 'Alternative to setting CLASSPATH' do |arg|
        options.classpath = arg.split ':'
      end

      opt.on '-l', '--lein', 'Fork leiningen commands and manage via a master process' do
        options.command = :lein
      end

      opt.on '--repl', 'Clojure REPL, wrapped by rlwrap if available' do
        options.command = :repl
      end

      opt.on '--lein-nailgun [PORT]', Integer, %Q(Same as `#{File.basename __FILE__} --lein "nailgun 127.0.0.1:PORT"`) do |arg|
        options.command = :lein_nailgun
        options.ngport = arg if arg
      end

      opt.on '-q', '--quiet' do
        options.quiet = true
      end

      opt.on '-h', '--help' do
        puts opt
        exit
      end
    end
  end

  def classpath *dirs
    ['~/.clojure/clojure.jar', *dirs, *options.classpath].map do |p|
      File.expand_path p
    end.join ':'
  end

  def rlwrap
    rl = %x(/bin/sh -c 'command -v rlwrap').chomp
    File.executable?(rl) ? [rl] : []
  end

  def lein_project_dir
    Pathname.new(Dir.pwd).ascend do |path|
      break path.to_s if File.exists? (path + 'project.clj').to_s
    end or File.expand_path '~/.clojure'
  end

  def lein_daemon *tasks
    pids = tasks.map do |t|
      fork do
        Dir.chdir lein_project_dir
        warn "[#{$$}] cd #{Dir.pwd}; lein #{t}" unless options.quiet
        exec 'lein', *t.shellsplit
      end
    end

    %w[TERM INT QUIT].each do |sig|
      trap sig do
        %w[TERM INT QUIT].each { |s| trap s, 'DEFAULT' }
        warn 'Caught SIG%s; sending SIGTERM to %s' % [sig, pids.join(', ')] unless options.quiet
        Process.kill :TERM, *pids
        Process.waitall
      end
    end

    Process.waitall
  end

  def execute args = []
    cmd = case options.command
    when :lein
      return lein_daemon(*args)
    when :repl
      rlwrap + %W[java -server -classpath #{classpath}] + args + %W[clojure.main]
    when :lein_nailgun
      return lein_daemon("nailgun 127.0.0.1:#{options.ngport}", *args)
    else
      %W[java -server -classpath #{classpath} clojure.main] + args
    end

    warn cmd.join(' ') unless options.quiet
    exec *cmd
  end

  def run arguments = []
    args = parser.superparse arguments
    execute args
  end
end

$0 = File.basename(__FILE__) and Clojure.new.run ARGV if $0 == __FILE__
