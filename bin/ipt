#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2014-2015 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'optparse'
require 'shellwords'

class Ipt
  DEFAULTS = {
    :protocol => 'tcp',
    :ipv4     => true,
    :ipv6     => false,
    :save4    => '/etc/iptables/iptables.rules',
    :save6    => '/etc/iptables/ip6tables.rules'
  }

  TABLES = %w[filter nat mangle raw security]

  def initialize opts = {}
    DEFAULTS.each_key { |k| instance_variable_set "@#{k}", opts.has_key?(k) ? opts[k] : DEFAULTS[k] }
  end

  def parser
    @parser ||= OptionParser.new nil, 20 do |opt|
      opt.banner = <<-BANNER.gsub /^ {8}/, ''
        iptables and ip6tables wrapper.

        Usage: #{File.basename __FILE__} [options] [command]

        Commands:
            l│list      Print rules (DEFAULT)
            s│save      Save rules to persistent path
            r│restore   Restore rules from persistent paths
            i│in        Accept INPUT from [src]:[dport,…] …
            I│IN        Accept INPUT with match on ctstate NEW + extra args
            o│out       Allow OUTPUT to [src]:[dport,…] …
            O│OUT       Allow OUTPUT with match on ctstate NEW + extra args
            f│forward   Forward traffic from [src]:[iface] to [dst]:[iface]
            F│FLUSH     Reset iptables
            A│ACCEPT    Set policy of tables to ACCEPT
            D│DROP      Set policy of tables to DROP
            h│help

        Options:
      BANNER

      opt.on '-a', '--all', 'IPv4 + IPv6' do
        @ipv4, @ipv6 = true, true
      end

      opt.on '-4', '--ipv4', 'IPv4 only (default)' do
        @ipv4, @ipv6 = true, false
      end

      opt.on '-6', '--ipv6', 'IPv6 only' do
        @ipv4, @ipv6 = false, true
      end

      opt.on '-P', '--protocol PROTO', 'Protocol when matching port numbers' do |arg|
        @protocol = arg
      end

      opt.on '-U', '--udp', 'Same as `--protocol udp`' do
        @protocol = 'udp'
      end

      opt.on '--save4 PATH', "Persistent iptables rules path; DEFAULT=#{@save4}" do |arg|
        @save4 = File.expand_path arg
      end

      opt.on '--save6 PATH', "Persistent ip6tables rules path; DEFAULT=#{@save6}" do |arg|
        @save6 = File.expand_path arg
      end
    end
  end

  def sh *args
    warn args.join(' ')
    system *args
  end

  def iptables_exec *args
    [[@ipv4, 'iptables'], [@ipv6, 'ip6tables']].each do |(enabled, cmd)|
      sh cmd, *args if enabled
    end
  end

  def colon_split arg
    a, b = arg.split ':', 2
    [a, b || '']
  end

  def maybe_pair pair
    prefix, value = pair
    if value and not value.empty?
      [prefix, value]
    else
      []
    end
  end

  def page s
    if $stdin.tty?
      IO.popen ENV['PAGER'] || 'less', 'w' do |io|
        io.puts s
      end
    else
      puts s
    end
  end

  def to_s
    TABLES.reduce '' do |s, t|
      [[@ipv4, 'IPv4', 'iptables'], [@ipv6, 'IPv6', 'ip6tables']].each do |(enabled, label, cmd)|
        if enabled
          s << "─── #{label} #{t} #{'─' * (80 - 5 - label.length - 1 - t.length)}\n\n"
          s << %x(#{cmd} --table #{t} --list --line-numbers --numeric --verbose 2>&1)
          s << "\n"
        end
      end
      s
    end
  end

  def save_rules!
    [[@ipv4, 'iptables-save', @save4], [@ipv6, 'ip6tables-save', @save6]].each do |(enabled, cmd, path)|
      sh "#{cmd} > #{path.shellescape}" if enabled
    end
  end

  def restore_rules!
    [[@ipv4, 'iptables-restore', @save4], [@ipv6, 'ip6tables-restore', @save6]].each do |(enabled, cmd, path)|
      sh "#{cmd} < #{path.shellescape}" if enabled and File.readable? path
    end
  end

  def accept! *args
    args.each do |arg|
      s, p = colon_split arg
      src = maybe_pair %W[--source #{s}]
      ps = p.split ','

      ports = case ps.size
      when 0 then []
      when 1 then %W[--protocol #{@protocol} --dport #{ps.first.to_s}]
      else        %W[--protocol #{@protocol} --match multiport --dports #{ps.join ','}]
      end

      accept_input! *(src + ports)
    end
  end

  def allow! *args
    args.each do |arg|
      s, p = colon_split arg
      src = maybe_pair %W[--destination #{s}]
      ps = p.split ','

      ports = case ps.size
      when 0 then []
      when 1 then %W[--protocol #{@protocol} --dport #{ps.first.to_s}]
      else        %W[--protocol #{@protocol} --match multiport --dports #{ps.join ','}]
      end

      allow_output! *(src + ports)
    end
  end

  def accept_input! *args
    iptables_exec *(%W[--insert INPUT] + args + %W[--match conntrack --ctstate NEW --jump ACCEPT])
  end

  def allow_output! *args
    iptables_exec *(%W[--insert OUTPUT] + args + %W[--match conntrack --ctstate NEW --jump ACCEPT])
  end

  def forward! src, dst
    src_addr, src_iface = colon_split src
    dst_addr, dst_iface = colon_split dst

    from_src_iface = maybe_pair %W[--in-interface  #{src_iface}]
    to_src_iface   = maybe_pair %W[--out-interface #{src_iface}]

    from_dst_iface = maybe_pair %W[--in-interface  #{dst_iface}]
    to_dst_iface   = maybe_pair %W[--out-interface #{dst_iface}]

    from_src_addr  = maybe_pair %W[--source        #{src_addr}]
    to_src_addr    = maybe_pair %W[--destination   #{src_addr}]

    from_dst_addr  = maybe_pair %W[--source        #{dst_addr}]
    to_dst_addr    = maybe_pair %W[--destination   #{dst_addr}]

    outbound = from_src_iface + from_src_addr + to_dst_iface + to_dst_addr
    inbound  = from_dst_iface + from_dst_addr + to_src_iface + to_src_addr

    # Outbound
    iptables_exec *(%W[--insert FORWARD 1] + outbound + %W[--jump ACCEPT])
    # Inbound
    iptables_exec *(%W[--insert FORWARD 2] + inbound + %W[--match conntrack --ctstate ESTABLISHED --jump ACCEPT])
    iptables_exec *(%W[--insert FORWARD 3] + inbound + %W[--match conntrack --ctstate INVALID     --jump DROP])
    iptables_exec *(%W[--insert FORWARD 4] + inbound + %W[--protocol icmp                         --jump ACCEPT])
    # Enable NAT
    iptables_exec *(%W[--table nat --insert POSTROUTING] + from_src_addr + to_dst_iface + to_dst_addr + %W[--jump MASQUERADE])
  end

  def flush_tables!
    # Flush rules and delete non-default chains
    TABLES.each do |t|
      iptables_exec *%W[--table #{t} --flush]
      iptables_exec *%W[--table #{t} --delete-chain]
    end

    # Reset default policies
    %W[INPUT FORWARD OUTPUT].each do |p|
      iptables_exec *%W[--policy #{p} ACCEPT]
    end
  end

  def set_policy! target, *tables
    tables.each do |table|
      iptables_exec *%W[--policy #{table} #{target}]
    end
  end

  def run arguments = []
    args = parser.order arguments

    case args.first
    when 'l', 'list', nil then page to_s
    when 's', 'save'      then save_rules!
    when 'r', 'restore'   then restore_rules!
    when 'i', 'in'        then accept! *args.drop(1)
    when 'I', 'IN'        then accept_input! *args.drop(1)
    when 'o', 'out'       then allow! *args.drop(1)
    when 'O', 'OUT'       then allow_output! *args.drop(1)
    when 'f', 'forward'   then forward! *args.drop(1)
    when 'F', 'FLUSH'     then flush_tables!
    when 'A', 'ACCEPT'    then set_policy! :ACCEPT, *args.drop(1)
    when 'D', 'DROP'      then set_policy! :DROP, *args.drop(1)
    when 'h', 'help'      then puts parser.help
    else abort parser.help
    end
  end
end

$0 = File.basename(__FILE__) and Ipt.new.run ARGV if $0 == __FILE__
