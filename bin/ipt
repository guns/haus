#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2014-2015 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'optparse'
require 'shellwords'

class Ipt
  DEFAULTS = {
    :protocol           => 'tcp',
    :ipv4               => true,
    :ipv6               => false,
    :save4              => '/etc/iptables/iptables.rules',
    :save6              => '/etc/iptables/ip6tables.rules',
    :drop_input_target  => 'DROPINPUT',
    :drop_output_target => 'DROPOUTPUT'
  }

  TABLES = %w[filter nat mangle raw security]

  def initialize opts = {}
    DEFAULTS.each_key { |k| instance_variable_set "@#{k}", opts.has_key?(k) ? opts[k] : DEFAULTS[k] }
  end

  def parser
    @parser ||= OptionParser.new nil, 32 do |opt|
      prog = File.basename __FILE__
      opt.banner = <<-BANNER.gsub /^ {8}/, ''
        iptables and ip6tables wrapper.

        Usage: #{prog} [options] [command]

        Commands:
            l│list      Print rules (DEFAULT)
            s│save      Save rules to persistent path
            r│restore   Restore rules from persistent paths
            i│in        Accept INPUT from [src]:[dport,…] …
            I│IN        Accept INPUT with match on ctstate NEW + extra args
           di│dropin    Drop INPUT from [src]:[dport,…] …
           DI│DROPIN    Drop INPUT with match on ctstate NEW + extra args
            o│out       Allow OUTPUT to [src]:[dport,…] …
            O│OUT       Allow OUTPUT with match on ctstate NEW + extra args
           do│dropout   Drop OUTPUT to [src]:[dport,…] …
           DO│DROPOUT   Drop OUTPUT with match on ctstate NEW + extra args
            f│forward   Forward traffic from [src]:[iface] to [dst]:[iface]
            F│FLUSH     Reset iptables
            p│policy    Set policy of tables to (A)ccept|(D)rop
             │            e.g. #{prog} p A INPUT OUTPUT FORWARD
            d│delete    Delete rules
             │            e.g. #{prog} in 192.168.1.0/24
             │                 #{prog} delete in 192.168.1.0/24
            z│zero      Reset counts in all tables
            h│help

        Options:
      BANNER

      opt.on '-a', '--all', 'IPv4 + IPv6' do
        @ipv4, @ipv6 = true, true
      end

      opt.on '-4', '--ipv4', 'IPv4 only (default)' do
        @ipv4, @ipv6 = true, false
      end

      opt.on '-6', '--ipv6', 'IPv6 only' do
        @ipv4, @ipv6 = false, true
      end

      opt.on '-P', '--protocol PROTO', 'Protocol when matching port numbers' do |arg|
        @protocol = arg
      end

      opt.on '-U', '--udp', 'Same as `--protocol udp`' do
        @protocol = 'udp'
      end

      opt.on '--drop-input-target TARGET', "Preferred --jump target when dropping INPUT packets; DEFAULT=#{@drop_input_target}" do |arg|
        @drop_input_target = arg
      end

      opt.on '--drop-output-target TARGET', "Preferred --jump target when dropping OUTPUT packets; DEFAULT=#{@drop_output_target}" do |arg|
        @drop_output_target = arg
      end

      opt.on '--save4 PATH', "Persistent iptables rules path; DEFAULT=#{@save4}" do |arg|
        @save4 = File.expand_path arg
      end

      opt.on '--save6 PATH', "Persistent ip6tables rules path; DEFAULT=#{@save6}" do |arg|
        @save6 = File.expand_path arg
      end
    end
  end

  def sh *args
    # Hack to suppress output on [:out, :err] => '/dev/null'
    warn args.join(' ') unless args.last.is_a? Hash
    system *args
  end

  def iptables_exec *args
    n = 0
    [[@ipv4, 'iptables', 1<<0], [@ipv6, 'ip6tables', 1<<1]].each do |(enabled, cmd, bit)|
      n |= (sh cmd, '--wait', *args if enabled) ? bit : 0
    end
    n
  end

  def colon_split arg
    i = arg.rindex ':'
    if i == nil
      [arg, '']
    else
      [arg[0...i], arg[i+1..-1]]
    end
  end

  def maybe_pair pair
    prefix, value = pair
    if value and not value.empty?
      [prefix, value]
    else
      []
    end
  end

  def page s
    if $stdin.tty?
      IO.popen ENV['PAGER'] || 'less', 'w' do |io|
        io.puts s
      end
    else
      puts s
    end
  end

  def to_s
    TABLES.reduce '' do |s, t|
      [[@ipv4, 'IPv4', 'iptables'], [@ipv6, 'IPv6', 'ip6tables']].each do |(enabled, label, cmd)|
        if enabled
          s << "─── #{label} #{t} #{'─' * (80 - 5 - label.length - 1 - t.length)}\n\n"
          s << %x(#{cmd} --table #{t} --list --line-numbers --numeric --verbose 2>&1)
          s << "\n"
        end
      end
      s
    end
  end

  def save_rules!
    [[@ipv4, 'iptables-save', @save4], [@ipv6, 'ip6tables-save', @save6]].each do |(enabled, cmd, path)|
      sh "#{cmd} > #{path.shellescape}" if enabled
    end
  end

  def restore_rules!
    [[@ipv4, 'iptables-restore', @save4], [@ipv6, 'ip6tables-restore', @save6]].each do |(enabled, cmd, path)|
      sh "#{cmd} < #{path.shellescape}" if enabled and File.readable? path
    end
  end

  def match_addr src_or_dst, addr
    if addr[0..3] == 'set:'
      addr = addr[4..-1]
      isipset = true
    end

    h, p = colon_split addr
    if isipset
      if h and h.size > 0
        src = ['--match', 'set', '--match-set', h, src_or_dst.to_s]
      else
        src = []
      end
    else
      src = maybe_pair [src_or_dst == :src ? '--source' : '--destination', h]
    end

    ps = p.split ','
    ports = case ps.size
            when 0 then []
            when 1 then %W[--protocol #{@protocol} --dport #{ps.first.to_s}]
            else        %W[--protocol #{@protocol} --match multiport --dports #{ps.join ','}]
            end

    src + ports
  end

  def accept_input_rule *args
    ['INPUT', *args, '--match', 'conntrack', '--ctstate', 'NEW', '--jump', 'ACCEPT']
  end

  def drop_input_rule *args
    ['INPUT', *args, '--jump', drop_input_target]
  end

  def allow_output_rule *args
    ['OUTPUT', *args, '--match', 'conntrack', '--ctstate', 'NEW', '--jump', 'ACCEPT']
  end

  def drop_output_rule *args
    ['OUTPUT', *args, '--jump', drop_output_target]
  end

  def check_and_insert! *rule
    if iptables_exec('--check', *rule, [:out, :err] => '/dev/null') == 0
      iptables_exec '--insert', *rule
    end
  end

  def check_and_delete! *rule
    if not iptables_exec('--check', *rule, [:out, :err] => '/dev/null') == 0
      iptables_exec '--delete', *rule
    end
  end

  def accept! *args
    args.each do |arg|
      check_and_insert! *accept_input_rule(*match_addr(:src, arg))
    end
  end

  def delete_accept! *args
    args.each do |arg|
      check_and_delete! *accept_input_rule(*match_addr(:src, arg))
    end
  end

  def dropin! *args
    args.each do |arg|
      check_and_insert! *drop_input_rule(*match_addr(:src, arg))
    end
  end

  def delete_dropin! *args
    args.each do |arg|
      check_and_delete! *drop_input_rule(*match_addr(:src, arg))
    end
  end

  def allow! *args
    args.each do |arg|
      check_and_insert! *allow_output_rule(*match_addr(:dst, arg))
    end
  end

  def delete_allow! *args
    args.each do |arg|
      check_and_delete! *allow_output_rule(*match_addr(:dst, arg))
    end
  end

  def dropout! *args
    args.each do |arg|
      check_and_insert! *drop_output_rule(*match_addr(:dst, arg))
    end
  end

  def delete_dropout! *args
    args.each do |arg|
      check_and_delete! *drop_output_rule(*match_addr(:dst, arg))
    end
  end

  def drop_input_target
    @__drop_input_target ||= begin
      if system 'iptables', '--list-rules', @drop_input_target, [:out, :err] => '/dev/null'
        @drop_input_target
      else
        'DROP'
      end
    end
  end

  def drop_output_target
    @__drop_output_target ||= begin
      if system 'iptables', '--list-rules', @drop_output_target, [:out, :err] => '/dev/null'
        @drop_output_target
      else
        'DROP'
      end
    end
  end

  def forwarding_rules src, dst
    src_addr, src_iface = colon_split src
    dst_addr, dst_iface = colon_split dst

    from_src_iface = maybe_pair %W[--in-interface  #{src_iface}]
    to_src_iface   = maybe_pair %W[--out-interface #{src_iface}]

    from_dst_iface = maybe_pair %W[--in-interface  #{dst_iface}]
    to_dst_iface   = maybe_pair %W[--out-interface #{dst_iface}]

    from_src_addr  = match_addr :src, src_addr
    to_src_addr    = match_addr :dst, src_addr

    from_dst_addr  = match_addr :src, dst_addr
    to_dst_addr    = match_addr :dst, dst_addr

    outbound = from_src_iface + from_src_addr + to_dst_iface + to_dst_addr
    inbound  = from_dst_iface + from_dst_addr + to_src_iface + to_src_addr

    [
      # Outbound
      ['FORWARD', '1', *outbound, '--jump', 'ACCEPT'],
      # Inbound
      ['FORWARD', '2', *inbound, '--match', 'conntrack', '--ctstate', 'ESTABLISHED', '--jump', 'ACCEPT'],
      ['FORWARD', '3', *inbound, '--match', 'conntrack', '--ctstate', 'INVALID',     '--jump', 'DROP'],
      ['FORWARD', '4', *inbound, '--protocol', 'icmp',                               '--jump', 'ACCEPT'],
      # Enable NAT
      ['POSTROUTING', '--table', 'nat', *from_src_addr, *to_dst_iface, *to_dst_addr, '--jump', 'MASQUERADE']
    ]
  end

  def forward! src, dst
    forwarding_rules(src, dst).each do |rule|
      check_and_insert! *rule
    end
  end

  def delete_forward! src, dst
    forwarding_rules(src, dst).each do |rule|
      rule.delete_at 1 if rule[1] =~ /\A\d+\z/
      check_and_delete! *rule
    end
  end

  def delete! *args
    case args.first
    when 'i',  'in'      then delete_accept! *args.drop(1)
    when 'I',  'IN'      then check_and_delete! *accept_input_rule(*args.drop(1))
    when 'di', 'dropin'  then delete_dropin! *args.drop(1)
    when 'DI', 'DROPIN'  then check_and_delete! *drop_input_rule(*args.drop(1))
    when 'o',  'out'     then delete_allow! *args.drop(1)
    when 'O',  'OUT'     then check_and_delete! *allow_output_rule(*args.drop(1))
    when 'do', 'dropout' then delete_dropout! *args.drop(1)
    when 'DO', 'DROPOUT' then check_and_delete! *drop_output_rule(*args.drop(1))
    when 'f',  'forward' then delete_forward! *args.drop(1)
    else
      iptables_exec '--delete', *args
    end
  end

  def flush_tables!
    # Flush rules and delete non-default chains
    TABLES.each do |t|
      iptables_exec *%W[--table #{t} --flush]
      iptables_exec *%W[--table #{t} --delete-chain]
    end

    # Reset default policies
    %W[INPUT FORWARD OUTPUT].each do |p|
      iptables_exec *%W[--policy #{p} ACCEPT]
    end
  end

  def set_policy! target, *tables
    policy = case target
    when /\Aa/i then 'ACCEPT'
    when /\Ad/i then 'DROP'
    else
      raise "Unknown policy: #{target}"
    end
    tables.each do |table|
      iptables_exec *%W[--policy #{table} #{policy}]
    end
  end

  def zero_tables!
    TABLES.each do |t|
      iptables_exec '--table', t, '--zero'
    end
  end

  def run arguments = []
    args = parser.order arguments

    case args.first
    when 'l',  'list', nil then page to_s
    when 's',  'save'      then save_rules!
    when 'r',  'restore'   then restore_rules!
    when 'i',  'in'        then accept! *args.drop(1)
    when 'I',  'IN'        then check_and_insert! *accept_input_rule(*args.drop(1))
    when 'di', 'dropin'    then dropin! *args.drop(1)
    when 'DI', 'DROPIN'    then check_and_insert! *drop_input_rule(*args.drop(1))
    when 'o',  'out'       then allow! *args.drop(1)
    when 'O',  'OUT'       then check_and_insert! *allow_output_rule(*args.drop(1))
    when 'do', 'dropout'   then dropout! *args.drop(1)
    when 'DO', 'DROPOUT'   then check_and_insert! *drop_output_rule(*args.drop(1))
    when 'f',  'forward'   then forward! *args.drop(1)
    when 'F',  'FLUSH'     then flush_tables!
    when 'p',  'policy'    then set_policy! *args.drop(1)
    when 'd',  'delete'    then delete! *args.drop(1)
    when 'z',  'zero'      then zero_tables!
    when 'h',  'help'      then puts parser.help
    else abort parser.help
    end
  end
end

$0 = File.basename(__FILE__) and Ipt.new.run ARGV if $0 == __FILE__
