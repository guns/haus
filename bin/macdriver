#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2012 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'optparse'
require 'ostruct'
require 'fileutils'
require 'yaml'
require 'plist'

class Macdriver
  # I am aware of RGL and TSort; this implementation for amusement only!
  class DirectedGraph
    class CyclicDependencyError < RuntimeError; end

    DIRECTION = { :in => 0, :out => 1 }

    attr_reader :table

    # Takes a list of vertices and outbound edges.
    def initialize list
      # The graph is actually stored in a hash table (a.k.a. adjacency list)
      @table = {}

      # Storing only incoming (or outgoing) edges per node allows for fast
      # appends, but storing both sets of edges per node allows for fast
      # bi-directional traversal, and simple reversals.
      #
      # We are interested in analyzing a static graph, so we choose the latter
      list.each do |v, es|
        # [inbound, outbound]
        table[v] ||= [[], []]
        es.each do |e|
          table[e] ||= [[], []]
          # Storing object references makes for expensive deep-copies, so we
          # just record the vertex ids instead.
          table[e][DIRECTION[:in ]].push v
          table[v][DIRECTION[:out]].push e
        end
      end
    end

    # Return a new graph rooted at given node.
    def subgraph id, direction = :in
      stack, dir = [], DIRECTION[direction]

      # Walk the graph, populating our new node list
      (walk = lambda do |v|
        es = table[v][dir]
        stack.push [v, es]
        es.each { |e| walk.call e }
      end).call id

      self.class.new stack
    end

    # Tarjan's topological sort. Order determined via reverse depth-first
    # traversal.
    def tsort
      visited, stack, dir = [], [], DIRECTION[:in]

      dfs = lambda do |v|
        if visited.include? v
          if stack.include? v
            next
          else
            # We are revisiting a node that is currently being traversed.
            raise CyclicDependencyError, '%s → %s → %s' % [v, table[v][dir].find(v).first, v]
          end
        end
        visited.push v
        table[v][dir].each { |e| dfs.call e }
        stack.push v
      end

      table.each_key { |id| dfs.call id }
      stack
    end

    # Return a new graph with edge directions swapped.
    def reverse
      self.class.new table.inject([]) { |s, (v, (ins, outs))| s.push [v, ins] }
    end

    def write files = nil
      # Graphviz is a heavy library dependency, so we load on demand
      require 'graphviz'

      files ||= ["#{self.class}.pdf"]
      opts = Hash[[files].flatten.map { |f| [File.extname(f).sub('.', '').intern, f] }]

      GraphViz.digraph :G, :rankdir => :LR do |g|
        g.add_nodes table.keys
        table.each { |v, (ins, outs)| g.add_edges v, outs }
      end.output opts
    end
  end

  HARDWARE_ALIASES = {
    'cd'          => 'com.apple.iokit.IOCDStorageFamily',
    'usb'         => 'com.apple.iokit.IOUSBFamily',
    'firewire'    => 'com.apple.iokit.IOFireWireFamily',
    'bluetooth'   => 'com.apple.iokit.IOBluetoothFamily',
    'thunderbolt' => 'com.apple.iokit.IOThunderboltFamily'
  }

  attr_reader :options

  def initialize opts = {}
    @options = OpenStruct.new opts
    options.jobs  ||= 4
    options.cache ||= "/tmp/#{self.class.to_s.downcase}-cache.yaml"
  end

  def parser
    @parser ||= OptionParser.new nil, 20 do |opt|
      opt.banner = %Q(\
        Query, graph, load, and unload kernel extensions. Kexts can be
        specified either by bundle identifier, or by an alias:

            #{HARDWARE_ALIASES.keys.join ', '}

        Loading and unloading kexts load and unload dependencies and
        dependents as necessary.

        Note that kext load state can be restored to boot conditions by
        sending SIGHUP to the `kextd` process.

        Usage: #{File.basename __FILE__} [options] [command [kext ...]]

        Options:
      ).gsub /^ {8}/, ''
    end
  end

  # Returns list of [kext-id, dependency-ids]
  def kextlist
    plists = Dir['{/System,}/Library/Extensions/**/*.kext/Contents/Info.plist']
    len,  vec,  idx  = plists.length, [], -1
    jobs, pool, lock = options.jobs,  [], Mutex.new

    # Threaded parsing of system kexts; ~35% speedup over single thread with
    # empty disk cache, and 100% more fun!
    jobs.times do |n|
      pool << Thread.new do
        loop do
          i = lock.synchronize { idx += 1 }
          break if i >= len
          id, deps = Plist.parse_xml(plists[i]).values_at 'CFBundleIdentifier', 'OSBundleLibraries'
          vec[i] = [id, (deps || {}).keys]
        end
      end
    end

    pool.each &:join
    vec
  end

  # Create and persist kext graph or load from cache
  def graph
    @graph ||= begin
      if options.reload or not File.exists? options.cache
        dg = DirectedGraph.new kextlist
        File.open(options.cache, 'w', 0644) { |f| f.puts dg.to_yaml }
        dg
      else
        YAML.load_file options.cache
      end
    end
  end

  def run arguments = []
    args = parser.parse arguments
  end
end

$0 = File.basename(__FILE__) and Macdriver.new.run ARGV if $0 == __FILE__
