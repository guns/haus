#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2012-2017 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'optparse'
require 'fileutils'
require 'yaml'

class Hwctl
  DEFAULTS = {
    :config => '/etc/hwctl.yml',
    :state_file => '/var/run/hwctl-state.yml',
    :sys => nil,
  }

  def initialize opts = {}
    DEFAULTS.each_key { |k| instance_variable_set "@#{k}", opts.has_key?(k) ? opts[k] : DEFAULTS[k] }
  end

  def parser
    @parser ||= OptionParser.new nil, 28 do |opt|
      opt.banner = <<-BANNER.gsub /^ {8}/, ''
        Linux hardware control wrapper.

        Usage: #{File.basename __FILE__} [options] command [args]

          Commands:
            [b]acklight [pct]
              Query or set backlight as a percentage. Argument can be signed
              for relative adjustment.

            bp mode user group
            backlight-permissions mode user group
              Set backlight control file permissions.

            [f]an
              Dump fan state to stdout.
            [f]an pct
              Set fan speeds as to given percentage. Writes current fan state
              to #{@state_file}
            [f]an [i]nteractive
              Read fan speeds as a percentage on stdin. Fan control state is
              restored on exit.
            [f]an [r]estore
              Restore fan state from #{@state_file}

            fnmode [fn|media]
            fnmode [2|1]
              Query or set laptop function key mode.

            toggle-pulseaudio-sink [index]
            toggle-pulseaudio-source [index]
              Set or toggle between available Pulseaudio output sinks and
              input sources.

          Options:
      BANNER

      opt.on '-c', '--config PATH', "DEFAULT: #{@config}" do |arg|
        @config = File.expand_path arg
      end

      opt.on '-f', '--state-file PATH', "DEFAULT: #{@state_file}" do |arg|
        @state_file = File.expand_path arg
      end
    end
  end

  def sys
    @sys ||= begin
      cfg = YAML.load_file @config
      %w[fan_manual fan_speed].each do |k|
        cfg[k] = [cfg[k]] unless cfg[k].is_a? Array
      end
      cfg
    end
  end

  def state_saved?
    File.readable? @state_file
  end

  def state
    YAML.load_file @state_file if state_saved?
  end

  def write_state map
    warn ":: Writing fan state to #{@state_file}"
    File.open @state_file, 'w', 0600 do |f|
      f.puts map.to_yaml
    end
  end

  def brightness cur, max
    '%d %.2f%%' % [cur, cur.to_f/max * 100]
  end

  def set_brightness value, max
    v = value
    v = max if value > max
    v = 0 if value < 0

    File.open sys['backlight'], 'w' do |f|
      f.puts v
    end

    v
  end

  def pulseaudio_list type
    raise ArgumentError unless ["sink", "source"].include? type

    list = %x(pacmd list-#{type}s).scan(/(\*?) index: (\d+).*?device\.description = "(.*?)"/m).map do |star, idx, desc|
      [star.length > 0, idx, desc]
    end

    until list[0][0]
      list.rotate!
    end

    list.map { |a| a.drop 1 }
  end

  def pulseaudio_move type, index
    type = { "sink" => "sink-input", "source" => "source-output" }[type]

    raise ArgumentError if type.nil?

    %x(pacmd list-#{type}s).lines.grep(/index: (\d+)/) { $1 }.each do |s|
      system 'pacmd', "move-#{type}", s.to_s, index.to_s, :out => '/dev/null'
    end
  end

  def get_temps
    sys['temps'].map { |f| File.read(f).to_i }
  end

  def backlight setting = nil
    max = File.read(sys['backlight_max']).to_i
    cur = File.read(sys['backlight_actual']).to_i

    case setting
    when nil           then brightness cur, max
    when /\A[+-]\d+\z/ then brightness set_brightness((cur + (max * (setting.to_f / 100))).round, max), max
    when /\A\d+\z/     then brightness set_brightness((max * (setting.to_f / 100)).round, max), max
    else raise ArgumentError
    end
  end

  def backlight_permissions mode, user, group
    f = sys['backlight']
    FileUtils.chmod (mode.kind_of?(Fixnum) ? mode : mode.to_i(8)), f
    FileUtils.chown user, group, f
    s = File.stat f
    '%o %s %s %s' % [s.mode, s.uid, s.gid, f]
  end

  def current_fan_state
    s = { 'fan_manual' => {}, 'fan_speed' => {} }
    sys['fan_manual'].each { |f| s['fan_manual'][f] = File.read(f).chomp }
    sys['fan_speed'].each { |f| s['fan_speed'][f] = File.read(f).chomp }
    s
  end

  def set_fan_speeds arg
    state = current_fan_state
    write_state state unless state_saved?

    sys['fan_manual'].each do |switch|
      if state['fan_manual'][switch] != '1'
        warn ":: #{switch} -> 1"
        File.open(switch, 'w') { |f| f.puts '1' }
      end
    end

    max = 255.0

    pct = case arg
    when /\A[+-]\d+\z/ then arg.to_f/100.0 + state['fan_speed'].to_a[0][1].to_i/max
    when /\A\d+\z/     then arg.to_i/100.0
    else raise ArgumentError
    end

    n = (0xff * pct).round.to_s

    sys['fan_speed'].each do |dial|
      warn ":: #{dial} -> #{n}"
      File.open(dial, 'w') { |f| f.puts n }
    end

    '%d %.2f%%' % [n, pct * 100]
  end

  def set_fan_speeds_interactively
    loop do
      input = $stdin.gets "\n"
      break if input.nil?
      set_fan_speeds input.chomp rescue ArgumentError
    end
  ensure
    restore_fan_state @state_file
  end

  def restore_fan_state file
    return false unless state_saved?

    warn ":: Restoring fan state from #{@state_file}"
    s = YAML.load_file file
    s.values_at('fan_speed', 'fan_manual').each do |h|
      h.each do |(k, v)|
        warn ":: #{k} -> #{v}"
        File.open k, 'w' do |f|
          f.puts v
        end
      end
    end
    FileUtils.rm_f file, :verbose => true
    "Restored fan state"
  end

  def fan arg = nil
    case arg
    when 'r', 'restore'     then restore_fan_state @state_file
    when 'i', 'interactive' then set_fan_speeds_interactively
    when /\A[+-]?\d+\z/     then set_fan_speeds arg
    when nil                then current_fan_state.to_yaml
    else raise ArgumentError
    end
  end

  def fnmode type = nil
    case type
    when '2', 'fn'    then File.open(sys['fnmode'], 'w') { |f| f.puts '2' }
    when '1', 'media' then File.open(sys['fnmode'], 'w') { |f| f.puts '1' }
    when nil          then nil
    else raise ArgumentError
    end
    File.read sys['fnmode']
  end

  def toggle_pulseaudio type, index = nil
    list = pulseaudio_list type

    if index
      i, desc = list.find { |(i, n)| i == index }
      raise "No #{type} at index #{index}" if i.nil?
    else
      i, desc = list.rotate.first
    end

    system 'pacmd', "set-default-#{type}", i, :out => '/dev/null'

    pulseaudio_move type, i
    desc
  end

  def run arguments = []
    args = parser.order arguments
    rest = args.drop 1

    out = case args.first
    when 'b', 'backlight'              then backlight *rest
    when 'bp', 'backlight-permissions' then backlight_permissions *rest
    when 'f', 'fan'                    then fan *rest
    when 'fnmode'                      then fnmode *rest
    when 'toggle-pulseaudio-sink'      then toggle_pulseaudio 'sink', *rest
    when 'toggle-pulseaudio-source'    then toggle_pulseaudio 'source', *rest
    else abort parser.help
    end

    puts out if out
    abort if out == false
  end
end

$0 = File.basename(__FILE__) and Hwctl.new.run ARGV if $0 == __FILE__
