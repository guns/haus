#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2011 Sung Pae <self@sungpae.com>
# Distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

require 'ostruct'
require 'shellwords'
require 'cli/superparser'

class RxvtUnicode # {{{1
  class Geometry # {{{2
    PATTERN = /(\d+)x(?:(\d+)(?:\+(\d+)(?:\+(\d+))?)?)?/

    class << self
      def parse str
        if m = str.match(PATTERN)
          new Hash[[:width, :height, :x, :y].zip m[1..4].map(&:to_i)]
        else
          new
        end
      end

      def parse_file file
        buf, line = File.read(file), ''

        %w[URxvt* Rxvt* Xterm* *].each do |prefix|
          rgx = Regexp.new "^\\s*#{Regexp.escape prefix}geometry:.*$", 'i'
          # Grab the last declaration
          if m = buf.scan(rgx).last
            line = m
            break
          end
        end

        parse line
      end
    end

    attr_accessor :width, :height, :y, :char, :border

    # FIXME: I don't know of a way to calculate a terminal's window size
    #        without creating a window and using xwininfo or echoing escape
    #        sequences; border size and pixels per column must be explicitly
    #        passed for now
    def initialize opts = {}
      @width, @height, self.x, @y = opts.values_at :width, :height, :x, :y
      @char   = opts[:char]   || 8
      @border = opts[:border] || 4
    end

    attr_reader :x

    def x= n
      @x = case n
      when 'left'   then 0
      when 'center' then xright / 2
      when 'right'  then xright
      else n
      end
    end

    def xright
      screen = %x(xrandr --query 2>/dev/null).match(PATTERN)[1].to_i
      screen - (width * char) - border
    end

    def to_s
      '%dx%d+%d+%d' % [width || 80, height || 24, x || 0, y || 0]
    end
  end # }}}2

  attr_reader :options, :geometry

  def initialize opts = {}
    @options = OpenStruct.new opts
    options.geometry ||= File.expand_path '~/.Xdefaults'
  end

  def parser
    @parser ||= CLI::SuperParser.new nil, 24 do |opt|
      opt.terminators << '-e'

      opt.banner = %Q(\
        Launch you an rxvt-unicode.

        Usage: #{File.basename __FILE__} [options] [-e command [args]]

        Options are a superset of urxvt(1); any options that are valid for
        urxvt(1) are valid for this program, with the addition of:

      ).gsub /^ +/, ''

      opt.on '-g', '--geometry HxW+X+Y', 'Set window geometry' do |arg|
        options.geometry = arg
      end

      opt.on '-c', '--client', 'Launch in client mode; launches urxvtd if not running' do
        options.client = true
      end

      %w[left center right].each do |pos|
        opt.on "--#{pos}" do
          options.position = pos
        end
      end

      opt.on '-h', '--help' do
        puts opt
        exit
      end
    end
  end

  def geometry
    geom = if options.geometry.nil?
      Geometry.new
    elsif File.exists? options.geometry
      Geometry.parse_file options.geometry
    else
      Geometry.parse options.geometry
    end

    geom.x = options.position if options.position
    geom
  end

  def env
    {
      'PATH'     => %x(bash ~/.bashpath).chomp,
      'RUBYLIB'  => %w[~/.haus/lib /opt/haus/lib].find { |d| File.directory? d },
      'LC_CTYPE' => 'en_US.UTF-8'
    }
  end

  def launch *args
    # We can pass an env hash to Kernel#system and friends in 1.9, but not in
    # in older Rubies, so we'll just do it this unsafe way.
    original = ENV.clone
    env.each { |k,v| ENV[k] = v }

    opts  = %W[-geometry #{geometry} --perl-lib #{File.expand_path '~/.urxvt/ext'}]
    opts += args

    if options.client
      # From urxvtc(1) man page
      system 'urxvtc', *opts
      if $?.exitstatus == 2
        system *%w[urxvtd -q -o -f]
        system 'urxvtc', *opts
      end
    else
      exec 'urxvt', *opts
    end
  ensure
    ENV.replace original
  end

  def run arguments = []
    args = parser.superparse arguments
    launch *args
  end
end

$0 = File.basename(__FILE__) and RxvtUnicode.new.run ARGV if $0 == __FILE__
