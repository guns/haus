# Snippets for Go

snippet APP "CLI application template" b
/*
 * Copyright (c) `date +%Y` Sung Pae <self@sungpae.com>
 */

package main

import (
	"fmt"
	"os"
	"path"

	"github.com/jessevdk/go-flags"
)

const usagesummary = \`[options]\`

type options struct {
}

func (opts *options) validate() error {
	switch {
	default:
		return nil
	}
}

func abort(err error) {
	if err != nil {
		_, _ = fmt.Fprintln(os.Stderr, err.Error()) // About to exit, ignore
	}
	os.Exit(1)
}

func abortWithHelp(parser *flags.Parser) {
	parser.WriteHelp(os.Stderr)
	os.Exit(1)
}

func getopts(arguments []string) (parser *flags.Parser, opts *options, args []string) {
	opts = new(options)
	var err error

	parser = flags.NewNamedParser(path.Base(arguments[0]), flags.HelpFlag|flags.PassDoubleDash)
	parser.Usage = usagesummary

	if _, err = parser.AddGroup("Options", "", opts); err != nil {
		abort(err)
	}

	if args, err = parser.ParseArgs(arguments[1:]); err != nil {
		abort(err)
	}

	if err := opts.validate(); err != nil {
		abort(err)
	}

	return parser, opts, args
}

func main() {
	$0// parser, opts, args := getopts(os.Args)
}
endsnippet

# when to abbriviate and when not?
# b doesn't work here, because it ignores whitespace
# optional local name?
snippet /^I/ "Import declaration" r
import (
	"${0:fmt}"
)
endsnippet

snippet /^p/ "package lib" r
package `!v expand('%:p:h:t')`
endsnippet

snippet /^P/ "package main" r
package main
endsnippet

# Mostly converted from: https://github.com/AlanQuatermain/go-tmbundle
snippet cs "Constants declaration" w
const (
	$0
)
endsnippet

snippet co "const" w
const $1 = $0
endsnippet

snippet V "var" w
var ${1:name} ${0:int}
endsnippet

snippet ve "var err error" w
var err error
endsnippet

snippet E "error" w
error
endsnippet

snippet vs "Variables declaration" w
var (
	$0
)
endsnippet

snippet pr "println" w
println($0)
endsnippet

snippet pf "fmt.Printf()" w
fmt.Printf($0)
endsnippet

snippet fpf "fmt.Fprintf()" w
fmt.Fprintf($0)
endsnippet

snippet fpl "fmt.Fprintln()" w
fmt.Fprintln($0)
endsnippet

snippet warn "warn" w
fmt.Fprint${1:ln}(os.Stderr, $0)
endsnippet

snippet pl "fmt.Println()" w
fmt.Println($0)
endsnippet

snippet sf "fmt.Sprintf()" w
fmt.Sprintf($0)
endsnippet

snippet ef "fmt.Errorf()" w
fmt.Errorf($0)
endsnippet

snippet en "errors.New()" w
errors.New($0)
endsnippet

snippet ssc "fmt.Sscan()" w
fmt.Sscan($0)
endsnippet

snippet pp "pretty.Println()" w
pretty.Println($0)
endsnippet

snippet iota "Iota constant generator" b
const (
	${1:constant}${2/(.+)/ /}${2:int} = iota
)
endsnippet

snippet b "Benchmark" b
func Benchmark$1(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		$0
	}
}
endsnippet

snippet t "Test" b
func Test$1(t *testing.T) {
	$0
}
endsnippet

snippet as "assert" w
if !(${1}) {
	t.Errorf("expected: $1${2:, actual: %v}$0")
}
endsnippet

snippet asf "assert false" w
if ${1} {
	t.Errorf("expected: !($1)${2:, actual: %v}$0")
}
endsnippet

snippet ase "assert equal" w
if ${1:actual} != ${2:expected} {
	t.Errorf("%v != %v", $1, $2$0)
}
endsnippet

snippet asde "assert deep equal" w
if !reflect.DeepEqual(${1:actual}, ${2:expected}) {
	t.Errorf("%v != %v", $1, $2$0)
}
endsnippet

snippet asn "assert nil" w
if ${1:err} != nil {
	t.Errorf("unexpected${2: error}: %v", $1$0)
}
endsnippet

snippet aser "assert error" w
if ${1:err} == nil {
	t.Errorf("expected $1 to be an error, but got nil"$0)
}
endsnippet

snippet asm "assert match" w
if !regexp.MatchString(\`${1}\`, ${3}) {
	t.Errorf(\`/$1/ !~ $3\`$0)
}
endsnippet

snippet ast "assert type" w
if reflect.TypeOf($1) != reflect.TypeOf($2) {
	t.Errorf("expected type %v, but got type %v", reflect.TypeOf($2), reflect.TypeOf($1)$0)
}
endsnippet

snippet L "len()" w
len($0)
endsnippet

snippet C "cap()" w
cap($0)
endsnippet

snippet S "[]string" w
[]string
endsnippet

snippet st "struct{}" w
struct{}
endsnippet

snippet T "type" b
type $0
endsnippet

snippet TS "type ()" w
type (
	$0
)
endsnippet

snippet ST "type struct" w
type ${1} struct {
	$0
}
endsnippet

snippet IF "type interface" b
type ${1} interface {
	$0
}
endsnippet

# statements
snippet for "For loop" !b
for ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet fori "for i := 0 …" w
for ${1:i} := ${2:0}; $1 ${3:<} ${4:n}; ${5:$1++} {
	$0
}
endsnippet

snippet forj "for j := 0 …" w
for ${1:j} := ${2:0}; $1 ${3:<} ${4:n}; ${5:$1++} {
	$0
}
endsnippet

snippet fors "for { select {} }" w
for {
	select {
	case $0:
	}
}
endsnippet

snippet forr "For range loop" !b
for ${1:i} := range ${2} {
	${0:${VISUAL}}
}
endsnippet

snippet fl "float64" w
float64
endsnippet

snippet f3 "float32" w
float32
endsnippet

snippet ui "uint" w
uint
endsnippet

snippet u8 "uint8" w
uint8
endsnippet

snippet u1 "uint16" w
uint16
endsnippet

snippet u3 "uint32" w
uint32
endsnippet

snippet u6 "uint64" w
uint64
endsnippet

snippet I "int" w
int
endsnippet

snippet i8 "int8" w
int8
endsnippet

snippet i1 "int16" w
int16
endsnippet

snippet i3 "int32" w
int32
endsnippet

snippet i6 "int64" w
int64
endsnippet

snippet B "[]byte" w
[]byte
endsnippet

snippet bb "bytes.Buffer" w
bytes.Buffer
endsnippet

snippet bi "bytes.Index()" w
bytes.Index(${1:haystack}, ${0:needle})
endsnippet

snippet bib "bytes.IndexByte()" w
bytes.IndexByte(${1:haystack}, ${0:needle})
endsnippet

snippet si "strings.Index()" w
strings.Index(${1:haystack}, ${0:needle})
endsnippet

snippet sib "strings.IndexByte()" w
strings.IndexByte(${1:haystack}, ${0:needle})
endsnippet

snippet sj "strings.Join()" w
strings.Join(${1:strings}, ${0:sep})
endsnippet

snippet ap "append" w
${1} = append($1, $0)
endsnippet

snippet ra "range" w
range $0
endsnippet

snippet if "If statement" !b
if ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet ifl "if let" w
if ${1} := ${2} {
	$0
}
endsnippet

snippet : "key: value" w
$1: $0,
endsnippet

snippet ife "if {} else {}" w
if $1 {
	$0
} else {
}
endsnippet

snippet ifer "if err != nil { return err }" w
if ${1:err} != nil {
	return $0$1
}
endsnippet

snippet ifle "if err := f(); err != nil …" w
if ${1:err} ${2::}= $3; $1 != nil {
	return $1$0
}
endsnippet

snippet el "else" w
else {
	$0
}
endsnippet

snippet eli "else if" w
else if $1 {
	$0
}
endsnippet

snippet sw "Switch statement" !b
switch ${1:expression}${1/(.+)/ /}{
case ${0}:
default:
}
endsnippet

snippet sel "select" !b
select {
case ${0}:
${1:default:
}}
endsnippet

snippet case "Case clause" !b
case ${1:condition}:
	${0:${VISUAL}}
endsnippet

snippet de "defer" w
defer $0
endsnippet

snippet def "defer func() { _ = … }" w
defer func() { _ = $0 }()
endsnippet

snippet defe "defer func() { …; err = }" w
defer func() {
	${1:e} := $0
	if ${2:err} == nil {
		$2 = $1
	}
}()
endsnippet

snippet mk "make()" w
make($0)
endsnippet

snippet mkc "make(chan …); close(…)" w
$1 := make(chan $2, $3)
${0:defer }close($1)
endsnippet

snippet cp "copy()" w
copy($0)
endsnippet

snippet N "new()" w
new($0)
endsnippet

# functions
snippet /^main/ "Main function" r
func main() {
	${0:${VISUAL}}
}
endsnippet

snippet /^fm/ "Method" r
func (${1:receiver} *${2:int}) ${3:name}(${4:params})${5/(.+)/ /}(${5:int}) {
	${0:${VISUAL}}
}
endsnippet

snippet /^f/ "Function" !r
func ${1}(${2})${3/(.+)/ /}(${3:int}) {
	${0:${VISUAL}}
}
endsnippet

snippet fn "Closure" w
func(${1})${2/(.+)/ /}(${2:int}) {
	${0:${VISUAL}}
}
endsnippet

snippet gof "go func" w
go func() {
	${0:${VISUAL}}
}()
endsnippet

snippet rf "ioutil.ReadFile()" w
$1, ${2:err} ${3::}= ioutil.ReadFile($0)
endsnippet

snippet rall "ioutil.ReadAll()" w
$1, ${2:err} ${3::}= ioutil.ReadAll($0)
endsnippet

snippet wf "ioutil.WriteFile()" w
${1:err} ${2::}= ioutil.WriteFile(${3:path}, ${4:bytes}, ${5:0644})
endsnippet

snippet O "file, err := os.Open(…)" w
${1:file}, ${2:err} ${3::}= os.Open($4)
if $2 != nil {
	return ${5:$2}
}
$0
if $2 = $1.Close(); $2 != nil {
	return $5
}
endsnippet

snippet W "file, err := os.Create(…)" w
${1:file}, ${2:err} ${3::}= os.Create($4)
if $2 != nil {
	return ${5:$2}
}
$0
if $2 = $1.Close(); $2 != nil {
	return $5
}
endsnippet

snippet rm "os.Remove()" w
${1:err} ${2::}= os.Remove($0)
endsnippet

snippet md "os.MkdirAll" w
${1:err} ${2::}= os.Mkdir${3:All}($4, ${5:0755})
endsnippet

snippet dne "if file does not exist" w
if _, ${1:err} ${2::}= os.Stat($3); os.IsNotExist(err) {
	$0
}
endsnippet

snippet fd "function decl" w
func($1)${2/(.+)/ /}(${2:int})
endsnippet

snippet r "return" w
return $0
endsnippet

snippet cl "close" w
close($0)
endsnippet

snippet pan "panic()" w
panic(${0:err})
endsnippet

# types and variables
snippet M "map" w
map[${1:keytype}]${0:valtype}
endsnippet

snippet str "string()" w
string($0)
endsnippet

snippet del "delete" w
delete($0)
endsnippet

snippet up "unsafe.Pointer" w
unsafe.Pointer
endsnippet

snippet tt "time.Time" w
time.Time
endsnippet

snippet ta "time.After()" w
time.After($1 * $0)
endsnippet

snippet taf "time.AfterFunc()" w
$1 ${2::}= time.AfterFunc($3 * $4) {
	$0
})
$5$1.Stop()
endsnippet

snippet tnt "time.NewTimer()" w
$1 ${2::}= time.NewTimer($3 * $4)
$0$1.Stop()
endsnippet

snippet tnT "time.NewTicker()" w
$1 ${2::}= time.NewTicker($3 * $4)
$0$1.Stop()
endsnippet

snippet sl "time.Sleep()" w
time.Sleep($1 * $0)
endsnippet

snippet tn "time.Now()" w
time.Now()
endsnippet

snippet td "time.Duration" w
time.Duration
endsnippet

snippet tD "time.Date" w
time.Date(${1:y}, ${2:m}, ${3:d}, ${4:0}, ${5:0}, ${6:0}, ${7:0}, ${8:time.Local})
endsnippet

snippet tl "time.Local" w
time.Local
endsnippet

snippet tu "time.UTC" w
time.UTC
endsnippet

snippet tN "time.Nanosecond" w
time.Nanosecond
endsnippet

snippet tM "time.Minute" w
time.Minute
endsnippet

snippet tm "time.Millisecond" w
time.Millisecond
endsnippet

snippet ts "time.Second" w
time.Second
endsnippet

snippet tH "time.Hour" w
time.Hour
endsnippet

snippet ch "chan" w
chan $0
endsnippet

snippet wg "sync.WaitGroup" w
sync.WaitGroup
endsnippet

snippet sm "sync.Mutex" w
sync.Mutex
endsnippet

snippet srw "sync.RWMutex" w
sync.RWMutex
endsnippet

snippet sc "strconv" w
strconv.
endsnippet

snippet ita "strconv.Itoa" w
strconv.Itoa($0)
endsnippet

snippet ati "strconv.Atoi" w
strconv.Atoi($0)
endsnippet

snippet fi "strconv.FormatInt" w
strconv.FormatInt($0, ${1:10})
endsnippet

snippet fu "strconv.FormatUint" w
strconv.FormatUint($0, ${1:10})
endsnippet

snippet ff "strconv.FormatFloat" w
strconv.FormatFloat($0, '${1:beEfgG}', ${2:prec}, ${3:32|64})
endsnippet

snippet alu "atomic.LoadUint32" w
atomic.LoadUint32(${0:addr})
endsnippet

snippet ali "atomic.LoadInt32" w
atomic.LoadInt32(${0:addr})
endsnippet

snippet alp "atomic.LoadPointer" w
atomic.LoadPointer(${0:addr})
endsnippet

snippet asu "atomic.StoreUint32" w
atomic.StoreUint32(${1:addr}, ${0:val})
endsnippet

snippet asi "atomic.StoreInt32" w
atomic.StoreInt32(${1:addr}, ${0:val})
endsnippet

snippet asp "atomic.StorePointer" w
atomic.StorePointer(${1:addr}, ${0:val})
endsnippet

snippet aau "atomic.AddUint32" w
atomic.AddUint32(${1:addr}, ${0:delta})
endsnippet

snippet aai "atomic.AddInt32" w
atomic.AddInt32(${1:addr}, ${0:delta})
endsnippet

snippet acasi "atomic.CompareAndSwapInt32" w
atomic.CompareAndSwapInt32(${1:addr}, ${2:old}, ${0:new})
endsnippet

snippet acasu "atomic.CompareAndSwapUint32" w
atomic.CompareAndSwapUint32(${1:addr}, ${2:old}, ${0:new})
endsnippet

snippet acasp "atomic.CompareAndSwapPointer" w
atomic.CompareAndSwapPointer(${1:addr}, ${2:old}, ${0:new})
endsnippet

snippet ns "bufio.NewScanner()" w
bufio.NewScanner($0)
endsnippet

snippet uu "*url.URL" w
*url.URL
endsnippet

snippet TN "trigger.New()" w
trigger.New()
endsnippet

snippet TT "*trigger.Trigger" w
*trigger.Trigger
endsnippet

snippet deb "breakpoint" w
runtime.Breakpoint()
endsnippet

snippet rr "regexp.Regexp" w
*regexp.Regexp
endsnippet

snippet rmc "regexp.MustCompile" w
regexp.MustCompile(\`$0\`)
endsnippet

# vim:ft=snippets:
