# Snippets for Go

snippet APP "CLI application template" b
/*
 * Copyright (c) `date +%Y` Sung Pae <self@sungpae.com>
 */

package main

const usage = \``!v expand('%:p:h:t')`\`

func abort(err error) {
	if err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
	}
	os.Exit(1)
}

func main() {
	$0
}
endsnippet

# when to abbriviate and when not?
# b doesn't work here, because it ignores whitespace
# optional local name?
snippet im "Import declaration" b
import (
	"${0:fmt}"
)
endsnippet

snippet /^p/ "package lib" r
package `!v expand('%:p:h:t')`
endsnippet

snippet /^P/ "package main" r
package main
endsnippet

# Mostly converted from: https://github.com/AlanQuatermain/go-tmbundle
snippet cs "Constants declaration" w
const (
	$0
)
endsnippet

snippet co "const" w
const $1 = $0
endsnippet

snippet V "var" w
var ${1:name} ${0:type}
endsnippet

snippet ve "var err error" w
var err error
endsnippet

snippet E "error" w
error
endsnippet

snippet vs "Variables declaration" w
var (
	$0
)
endsnippet

snippet pr "println" w
println($0)
endsnippet

snippet pf "fmt.Printf()" w
fmt.Printf("${1}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\);)/}$2${1/([^%]|%%)*(%.)?.*/(?2:\);)/}
endsnippet

snippet fpf "fmt.Fprintf()" w
fmt.Fprintf("${1}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\);)/}$2${1/([^%]|%%)*(%.)?.*/(?2:\);)/}
endsnippet

snippet fpl "fmt.Fprintln()" w
fmt.Fprintln($0)
endsnippet

snippet warn "warn" w
fmt.Fprint${1:ln}(os.Stderr, $0)
endsnippet

snippet pl "fmt.Println()" w
fmt.Println($0)
endsnippet

snippet sf "fmt.Sprintf()" w
fmt.Sprintf("${1}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\);)/}$2${1/([^%]|%%)*(%.)?.*/(?2:\);)/}
endsnippet

snippet lf "log.Printf" w
log.Printf("${1}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\);)/}$2${1/([^%]|%%)*(%.)?.*/(?2:\);)/}
endsnippet

snippet lp "log.Print" w
log.Print($0)
endsnippet

snippet ll "log.Println" w
log.Println($0)
endsnippet

snippet ef "fmt.Errorf()" w
fmt.Errorf($0)
endsnippet

snippet en "errors.New()" w
errors.New($0)
endsnippet

snippet ew "errors.Wrap()" w
errors.Wrap($0)
endsnippet

snippet ews "errors.WithStack()" w
errors.WithStack($0)
endsnippet

snippet ssc "fmt.Sscan()" w
fmt.Sscan($0)
endsnippet

snippet pp "pretty.Println()" w
pretty.Println($0)
endsnippet

snippet iota "Iota constant generator" b
const (
	${1:constant}${2/(.+)/ /}${2:type} = iota
)
endsnippet

snippet /^b/ "Benchmark" r
func Benchmark$1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		$0
	}
}
endsnippet

snippet /^t/ "Test" r
func Test$1(t *testing.T) {
	$0
}
endsnippet

snippet /^tmain/ "TestMain" r
func TestMain(m *testing.M) {
	$0
	os.Exit(m.Run())
}
endsnippet

snippet table "table driven test" b
data := []struct{
	$1
}{
	{$2},
}

for _, row := range data {
	$0
}
endsnippet

snippet as "assert" w
if !(${1}) {
	t.Errorf("expected: $1${2:, actual: %v}$0")
}
endsnippet

snippet asf "assert false" w
if ${1} {
	t.Errorf("expected: !($1)${2:, actual: %v}$0")
}
endsnippet

snippet ase "assert equal" w
if ${1:actual} != ${2:expected} {
	t.Errorf("%v != %v", $1, $2$0)
}
endsnippet

snippet asde "assert deep equal" w
if !reflect.DeepEqual(${1:actual}, ${2:expected}) {
	t.Errorf("%v != %v", $1, $2$0)
}
endsnippet

snippet asn "assert nil" w
if ${1:err} != nil {
	t.Errorf("unexpected${2: error}: %v", $1$0)
}
endsnippet

snippet aser "assert error" w
if ${1:err} == nil {
	t.Errorf("expected $1 to be an error, but got nil"$0)
}
endsnippet

snippet asm "assert match" w
${1:r} := regexp.MustCompile(${2})
if !$1.MatchString(${3}) {
	t.Errorf("%v !~ %v", $3, $2)$0
}
endsnippet

snippet ast "assert type" w
if reflect.TypeOf($1) != reflect.TypeOf($2) {
	t.Errorf("expected type %v, but got type %v", reflect.TypeOf($2), reflect.TypeOf($1)$0)
}
endsnippet

snippet asl "assert log" w
t.Logf("${1}", $0)
endsnippet

snippet asF "assert fail" w
t.Fail()
endsnippet

snippet asE "assert errorf" w
t.Errorf("${1}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\);)/}$2${1/([^%]|%%)*(%.)?.*/(?2:\);)/}
endsnippet

snippet L "len()" w
len($0)
endsnippet

snippet C "cap()" w
cap($0)
endsnippet

snippet S "[]string" w
[]string
endsnippet

snippet st "struct{}" w
struct{}
endsnippet

snippet T "type" b
type $0
endsnippet

snippet TS "type struct" w
type ${1} struct {
	$0
}
endsnippet

snippet IF "type interface" b
type ${1} interface {
	$0
}
endsnippet

# statements
snippet for "For loop" !b
for ${1}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet fori "for i := 0 …" w
for ${1:i} := 0; $1 < ${2:n}; $1++ {
	$0
}
endsnippet

snippet forir "for i reverse" w
for ${1:i} := ${2:${3:n} - 1}; $1 >= 0; $1-- {
	$0
}
endsnippet

snippet fors "for { select {} }" w
for {
	select {
	case $0:
	}
}
endsnippet

snippet forl "For range loop" !b
for ${1:i} := range ${2} {
	${0:${VISUAL}}
}
endsnippet

snippet fl "float64" w
float64
endsnippet

snippet f3 "float32" w
float32
endsnippet

snippet ui "uint" w
uint
endsnippet

snippet u8 "uint8" w
uint8
endsnippet

snippet u1 "uint16" w
uint16
endsnippet

snippet u3 "uint32" w
uint32
endsnippet

snippet u6 "uint64" w
uint64
endsnippet

snippet uip "uintptr" w
uintptr
endsnippet

snippet I "interface{}" w
interface{}
endsnippet

snippet i8 "int8" w
int8
endsnippet

snippet i1 "int16" w
int16
endsnippet

snippet i3 "int32" w
int32
endsnippet

snippet i6 "int64" w
int64
endsnippet

snippet B "[]byte" w
[]byte
endsnippet

snippet bb "bytes.Buffer" w
bytes.Buffer
endsnippet

snippet bi "bytes.Index()" w
bytes.Index(${1:haystack}, ${0:needle})
endsnippet

snippet bib "bytes.IndexByte()" w
bytes.IndexByte(${1:haystack}, ${0:needle})
endsnippet

snippet si "strings.Index()" w
strings.Index(${1:haystack}, ${0:needle})
endsnippet

snippet sib "strings.IndexByte()" w
strings.IndexByte(${1:haystack}, ${0:needle})
endsnippet

snippet sj "strings.Join()" w
strings.Join(${1:strings}, ${0:sep})
endsnippet

snippet stl "strings.ToLower" w
strings.ToLower($0)
endsnippet

snippet sb "strings.Builder" w
strings.Builder
endsnippet

snippet shp "strings.HasPrefix" w
strings.HasPrefix(${1:string}, ${0:prefix})
endsnippet

snippet shs "strings.HasSuffix" w
strings.HasSuffix(${1:string}, ${0:suffix})
endsnippet

snippet sts "strings.TrimSpace" w
strings.TrimSpace($0)
endsnippet

snippet spl "strings.Split" w
strings.Split($0)
endsnippet

snippet fj "filepath.Join()" w
filepath.Join($0)
endsnippet

snippet pj "path.Join" w
path.Join($0)
endsnippet

snippet ap "append" w
${1} = append($1, $0)
endsnippet

snippet ra "range" w
range $0
endsnippet

snippet if "If statement" !b
if ${1} {
	${0:${VISUAL}}
}
endsnippet

snippet ifl "if let" w
if ${1} := ${2} {
	$0
}
endsnippet

snippet : "key: value" w
$1: $0,
endsnippet

snippet ife "if err != nil { return err }" w
if ${1:err} != nil {
	return $1$0
}
endsnippet

snippet ifle "if err := f(); err != nil …" w
if ${1:err} ${2::}= $3; $1 != nil {
	return $1$0
}
endsnippet

snippet ern "err != nil {}" w
${1:err} != nil {
	return $1$0
}
endsnippet

snippet el "else" w
else {
	$0
}
endsnippet

snippet eli "else if" w
else if $1 {
	$0
}
endsnippet

snippet sw "Switch statement" !b
switch ${1}${1/(.+)/ /}{
case ${0}:
default:
}
endsnippet

snippet sel "select" !b
select {
case ${0}:
${1:default:
}}
endsnippet

snippet case "Case clause" !b
case ${1}:
	${0:${VISUAL}}
endsnippet

snippet de "defer" w
defer $0
endsnippet

snippet def "defer func() {}()" w
defer func() { $0 }()
endsnippet

snippet defj "defer errutil.Join(…)" w
defer func() {
	${1:err} = errutil.Join(${2:" • "}, $1, $0)
}()
endsnippet

snippet defe "defer errutil.First(…)" w
defer func() {
	${1:err} = errutil.First($1, $0)}
}()
endsnippet

snippet euj "errutil.Join" w
errutil.Join("${1:; }", $0)
endsnippet

snippet euf "errutil.First" w
errutil.First($0)
endsnippet

snippet mk "make()" w
make($0)
endsnippet

snippet mkc "make(chan …); close(…)" w
$1 := make(chan $2, $3)
${0:defer }close($1)
endsnippet

snippet cp "copy()" w
copy($0)
endsnippet

snippet N "new()" w
new($0)
endsnippet

# functions
priority 1
snippet /^main/ "Main function" r
func main() {
	${0:${VISUAL}}
}
endsnippet

snippet /^m/ "Method Pointer Receiver" r
func (${1} *${2:T}) ${3:name}(${4:params})${5/(.+)/(?1: :)/}(${5}) {
	${0:${VISUAL}}
}
endsnippet

snippet /^M/ "Method Value Receiver" r
func (${1} ${2:T}) ${3:name}(${4:params})${5/(.+)/(?1: :)/}(${5}) {
	${0:${VISUAL}}
}
endsnippet

snippet /^n/ "NewType" r
func New${1}(${2}) (*$1${3:, err}) {
	$0
}
endsnippet

snippet /^N/ "MakeType" r
func Make${1}(${2}) ($1${3:, err}) {
	$0
}
endsnippet
priority 0

snippet /^f/ "Function" !r
func ${1}(${2})${3/(.+)/ /}(${3}) {
	${0:${VISUAL}}
}
endsnippet

snippet fn "Closure" w
func(${1})${2/(.+)/ /}(${2}) {
	${0:${VISUAL}}
}
endsnippet

snippet gof "go func" w
go func() {
	${0:${VISUAL}}
}()
endsnippet

snippet rf "ioutil.ReadFile()" w
$1, ${2:err} ${3::}= ioutil.ReadFile($0)
endsnippet

snippet rall "ioutil.ReadAll()" w
$1, ${2:err} ${3::}= ioutil.ReadAll($0)
endsnippet

snippet wf "ioutil.WriteFile()" w
${1:err} ${2::}= ioutil.WriteFile(${3:path}, ${4:bytes}, ${5:0644})
endsnippet

snippet O "file, err := os.Open(…)" w
${1:file}, ${2:err} ${3::}= os.Open($4)
if $2 != nil {
	return ${5:$2}
}
$0
if $2 = $1.Close(); $2 != nil {
	return $5
}
endsnippet

snippet osc "file, err := os.Create(…)" w
${1:file}, ${2:err} ${3::}= os.Create($4)
if $2 != nil {
	return $2
}
defer func() { ${5:err} = errutil.First($2, $1.Close()) }()
$0
endsnippet

snippet of "open file" w
os.OpenFile(${1:path}, os.O_CREATE$0, ${2:0644})
endsnippet

snippet rm "os.Remove()" w
${1:err} ${2::}= os.Remove($0)
endsnippet

snippet md "os.MkdirAll" w
${1:err} ${2::}= os.Mkdir${3:All}($4, ${5:0755})
endsnippet

snippet dne "if file does not exist" w
if _, ${1:err} ${2::}= os.Stat($3); os.IsNotExist(err) {
	$0
}
endsnippet

snippet fd "function decl" w
func($1)${2/(.+)/ /}(${2})
endsnippet

snippet r "return" w
return $0
endsnippet

snippet cl "close" w
close($0)
endsnippet

snippet pan "panic()" w
panic(${0:err})
endsnippet

snippet exit "os.Exit()" w
os.Exit($0)
endsnippet

# types and variables
snippet M "map" w
map[${1:keytype}]${0:valtype}
endsnippet

snippet str "string()" w
string($0)
endsnippet

snippet del "delete" w
delete($0)
endsnippet

snippet up "unsafe.Pointer" w
unsafe.Pointer
endsnippet

snippet tt "time.Time" w
time.Time
endsnippet

snippet ta "time.After()" w
time.After($1 * $0)
endsnippet

snippet taf "time.AfterFunc()" w
$1 ${2::}= time.AfterFunc($3 * $4) {
	$0
})
$5$1.Stop()
endsnippet

snippet tnt "time.NewTimer()" w
$1 ${2::}= time.NewTimer($3 * $4)
$0$1.Stop()
endsnippet

snippet tnT "time.NewTicker()" w
$1 ${2::}= time.NewTicker($3 * $4)
$0$1.Stop()
endsnippet

snippet sl "time.Sleep()" w
time.Sleep($1 * $0)
endsnippet

snippet tn "time.Now()" w
time.Now()
endsnippet

snippet td "time.Duration" w
time.Duration
endsnippet

snippet tD "time.Date" w
time.Date(${1:y}, ${2:m}, ${3:d}, ${4:0}, ${5:0}, ${6:0}, ${7:0}, ${8:time.Local})
endsnippet

snippet tl "time.Local" w
time.Local
endsnippet

snippet tu "time.UTC" w
time.UTC
endsnippet

snippet tN "time.Nanosecond" w
time.Nanosecond
endsnippet

snippet tM "time.Minute" w
time.Minute
endsnippet

snippet tm "time.Millisecond" w
time.Millisecond
endsnippet

snippet ts "time.Second" w
time.Second
endsnippet

snippet tH "time.Hour" w
time.Hour
endsnippet

snippet tS "time.Since" w
time.Since($0)
endsnippet

snippet ch "chan" w
chan $0
endsnippet

snippet wg "sync.WaitGroup" w
sync.WaitGroup
endsnippet

snippet sm "sync.Mutex" w
sync.Mutex
endsnippet

snippet srw "sync.RWMutex" w
sync.RWMutex
endsnippet

snippet sc "strconv" w
strconv.
endsnippet

# snippet ita "strconv.Itoa" w
# strconv.Itoa($0)
# endsnippet

# snippet ati "strconv.Atoi" w
# strconv.Atoi($0)
# endsnippet

snippet spi "strconv.ParseInt" w
strconv.ParseInt(${1:string}, ${2:base}, ${3:bitsize})
endsnippet

snippet sfi "strconv.FormatInt" w
strconv.FormatInt($0, ${1:10})
endsnippet

snippet sfu "strconv.FormatUint" w
strconv.FormatUint($0, ${1:10})
endsnippet

snippet sff "strconv.FormatFloat" w
strconv.FormatFloat($0, '${1:beEfgG}', ${2:prec}, ${3:32|64})
endsnippet

snippet alu "atomic.LoadUint32" w
atomic.LoadUint32(${0:addr})
endsnippet

snippet ali "atomic.LoadInt32" w
atomic.LoadInt32(${0:addr})
endsnippet

snippet alp "atomic.LoadPointer" w
atomic.LoadPointer(${0:addr})
endsnippet

snippet asu "atomic.StoreUint32" w
atomic.StoreUint32(${1:addr}, ${0:val})
endsnippet

snippet asi "atomic.StoreInt32" w
atomic.StoreInt32(${1:addr}, ${0:val})
endsnippet

snippet asp "atomic.StorePointer" w
atomic.StorePointer(${1:addr}, ${0:val})
endsnippet

snippet aau "atomic.AddUint32" w
atomic.AddUint32(${1:addr}, ${0:delta})
endsnippet

snippet aai "atomic.AddInt32" w
atomic.AddInt32(${1:addr}, ${0:delta})
endsnippet

snippet acasi "atomic.CompareAndSwapInt32" w
atomic.CompareAndSwapInt32(${1:addr}, ${2:old}, ${0:new})
endsnippet

snippet acasu "atomic.CompareAndSwapUint32" w
atomic.CompareAndSwapUint32(${1:addr}, ${2:old}, ${0:new})
endsnippet

snippet acasp "atomic.CompareAndSwapPointer" w
atomic.CompareAndSwapPointer(${1:addr}, ${2:old}, ${0:new})
endsnippet

snippet ns "bufio.NewScanner()" w
bufio.NewScanner($0)
endsnippet

snippet uu "*url.URL" w
*url.URL
endsnippet

snippet TN "trigger.New()" w
trigger.New()
endsnippet

snippet TT "*trigger.T" w
*trigger.T
endsnippet

snippet deb "breakpoint" w
runtime.Breakpoint()
endsnippet

snippet rr "regexp.Regexp" w
*regexp.Regexp
endsnippet

snippet rmc "regexp.MustCompile" w
regexp.MustCompile(\`$0\`)
endsnippet

snippet sN "signal.Notify" w
signal.Notify(${1:sigch}, syscall.SIG$0)
endsnippet

snippet hf "http.Handler fn" b
func ${1:name}(w http.ResponseWriter, r *http.Request) {
	$0
}
endsnippet

snippet hm "http.Handler method" b
func (${1:app *App}) ${2:name}(w http.ResponseWriter, r *http.Request) {
	$0
}
endsnippet

snippet hM "http.Handler middleware" b
func ${1:(${2:app *App}) }${3:name}(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		$0
		h.ServeHTTP(w, r)
	})
}
endsnippet

snippet hargs "w http.ResponseWriter, r *http.Request" w
w http.ResponseWriter, r *http.Request
endsnippet

snippet cwt "context.WithTimeout" w
ctx, cancel := context.WithTimeout($0)
defer cancel()
endsnippet

snippet cwd "context.WithDeadline" w
ctx, cancel := context.WithDeadline($0)
defer cancel()
endsnippet

snippet cb "context.Background" w
context.Background()
endsnippet

snippet cc "context.Context" w
context.Context
endsnippet

snippet ze "zap.Error(err)" w
zap.Error(${1:err})
endsnippet

snippet zs "zap.String()" w
zap.String("$1", $0)
endsnippet

snippet ior "io.Reader" w
io.Reader
endsnippet

snippet iow "io.Writer" w
io.Writer
endsnippet

snippet eof "io.EOF" w
io.EOF
endsnippet

snippet hes "hex.EncodeToString()" w
hex.EncodeToString($0)
endsnippet

snippet hds "hex.DecodeString()" w
${1:${2:bs}, ${3:err} ${4::}= }hex.DecodeString($0)
endsnippet

snippet ctc "subtle.ConstantTimeCompare" w
subtle.ConstantTimeCompare($0)
endsnippet

snippet sortimpl "sort.Interface implementation" w
${3:type $2 []${4:type}}
func (${1:s} ${2:slice}) Len() int           { return len($1)$0 }
func ($1 $2) Swap(i, j int)      { $1[i], $1[j] = $1[j], $1[i] }
func ($1 $2) Less(i, j int) bool { return $1[i]${5} < $1[j]$5 }
endsnippet

snippet exc "exec.Command()" w
exec.Command($0)
endsnippet

snippet osf "*os.File" w
*os.File
endsnippet

snippet memprof "debug.StartMemProfile" w
stopMemProfile := debug.StartMemProfile("${1:mem.prof}")
stopMemProfile()
endsnippet

snippet cpuprof "debug.StartCPUProfile"
stopCPUProfile := debug.StartCPUProfile("${1:cpu.prof}")
stopCPUProfile()
endsnippet

# vim:ft=snippets:
